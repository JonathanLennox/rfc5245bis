<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal </title>

<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
/*]]>*/</style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Overview of ICE"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Gathering Candidate Addresses"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Connectivity Checks"/>
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Sorting Candidates"/>
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 Frozen Candidates"/>
<link href="#rfc.section.2.5" rel="Chapter" title="2.5 Security for Checks"/>
<link href="#rfc.section.2.6" rel="Chapter" title="2.6 Concluding ICE"/>
<link href="#rfc.section.2.7" rel="Chapter" title="2.7 Lite Implementations"/>
<link href="#rfc.section.2.8" rel="Chapter" title="2.8 Usages of ICE"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Terminology"/>
<link href="#rfc.section.4" rel="Chapter" title="4 ICE Candidate Gathering and Exchange"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Procedures for Full Implementation"/>
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 Gathering Candidates"/>
<link href="#rfc.section.4.1.1.1" rel="Chapter" title="4.1.1.1 Host Candidates"/>
<link href="#rfc.section.4.1.1.2" rel="Chapter" title="4.1.1.2 Server Reflexive and Relayed Candidates"/>
<link href="#rfc.section.4.1.1.3" rel="Chapter" title="4.1.1.3 Computing Foundations"/>
<link href="#rfc.section.4.1.1.4" rel="Chapter" title="4.1.1.4 Keeping Candidates Alive"/>
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 Prioritizing Candidates"/>
<link href="#rfc.section.4.1.2.1" rel="Chapter" title="4.1.2.1 Recommended Formula"/>
<link href="#rfc.section.4.1.2.2" rel="Chapter" title="4.1.2.2 Guidelines for Choosing Type and Local Preferences"/>
<link href="#rfc.section.4.1.3" rel="Chapter" title="4.1.3 Eliminating Redundant Candidates"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Lite Implementation Procedures"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Encoding the Candidate Information"/>
<link href="#rfc.section.5" rel="Chapter" title="5 ICE Candidate Processing"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Procedures for Full Implementation"/>
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 Verifying ICE Support"/>
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 Determining Role"/>
<link href="#rfc.section.5.1.3" rel="Chapter" title="5.1.3 Forming the Check Lists"/>
<link href="#rfc.section.5.1.3.1" rel="Chapter" title="5.1.3.1 Forming Candidate Pairs"/>
<link href="#rfc.section.5.1.3.2" rel="Chapter" title="5.1.3.2 Computing Pair Priority and Ordering Pairs"/>
<link href="#rfc.section.5.1.3.3" rel="Chapter" title="5.1.3.3 Pruning the Pairs"/>
<link href="#rfc.section.5.1.3.4" rel="Chapter" title="5.1.3.4 Computing States"/>
<link href="#rfc.section.5.1.4" rel="Chapter" title="5.1.4 Scheduling Checks"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Lite Implementation Procedures"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Performing Connectivity Checks"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 STUN Client Procedures"/>
<link href="#rfc.section.6.1.1" rel="Chapter" title="6.1.1 Creating Permissions for Relayed Candidates"/>
<link href="#rfc.section.6.1.2" rel="Chapter" title="6.1.2 Sending the Request"/>
<link href="#rfc.section.6.1.2.1" rel="Chapter" title="6.1.2.1 PRIORITY and USE-CANDIDATE"/>
<link href="#rfc.section.6.1.2.2" rel="Chapter" title="6.1.2.2 ICE-CONTROLLED and ICE-CONTROLLING"/>
<link href="#rfc.section.6.1.2.3" rel="Chapter" title="6.1.2.3 Forming Credentials"/>
<link href="#rfc.section.6.1.2.4" rel="Chapter" title="6.1.2.4 DiffServ Treatment"/>
<link href="#rfc.section.6.1.3" rel="Chapter" title="6.1.3 Processing the Response"/>
<link href="#rfc.section.6.1.3.1" rel="Chapter" title="6.1.3.1 Failure Cases"/>
<link href="#rfc.section.6.1.3.2" rel="Chapter" title="6.1.3.2 Success Cases"/>
<link href="#rfc.section.6.1.3.2.1" rel="Chapter" title="6.1.3.2.1 Discovering Peer Reflexive Candidates"/>
<link href="#rfc.section.6.1.3.2.2" rel="Chapter" title="6.1.3.2.2 Constructing a Valid Pair"/>
<link href="#rfc.section.6.1.3.2.3" rel="Chapter" title="6.1.3.2.3 Updating Pair States"/>
<link href="#rfc.section.6.1.3.2.4" rel="Chapter" title="6.1.3.2.4 Updating the Nominated Flag"/>
<link href="#rfc.section.6.1.3.3" rel="Chapter" title="6.1.3.3 Check List and Timer State Updates"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 STUN Server Procedures"/>
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 Additional Procedures for Full Implementations"/>
<link href="#rfc.section.6.2.1.1" rel="Chapter" title="6.2.1.1 Detecting and Repairing Role Conflicts"/>
<link href="#rfc.section.6.2.1.2" rel="Chapter" title="6.2.1.2 Computing Mapped Address"/>
<link href="#rfc.section.6.2.1.3" rel="Chapter" title="6.2.1.3 Learning Peer Reflexive Candidates"/>
<link href="#rfc.section.6.2.1.4" rel="Chapter" title="6.2.1.4 Triggered Checks"/>
<link href="#rfc.section.6.2.1.5" rel="Chapter" title="6.2.1.5 Updating the Nominated Flag"/>
<link href="#rfc.section.6.2.2" rel="Chapter" title="6.2.2 Additional Procedures for Lite Implementations"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Concluding ICE Processing"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Procedures for Full Implementations"/>
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 Nominating Pairs"/>
<link href="#rfc.section.7.1.1.1" rel="Chapter" title="7.1.1.1 Regular Nomination"/>
<link href="#rfc.section.7.1.1.2" rel="Chapter" title="7.1.1.2 Aggressive Nomination"/>
<link href="#rfc.section.7.1.2" rel="Chapter" title="7.1.2 Updating States"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Procedures for Lite Implementations"/>
<link href="#rfc.section.7.2.1" rel="Chapter" title="7.2.1 Peer Is Full"/>
<link href="#rfc.section.7.2.2" rel="Chapter" title="7.2.2 Peer Is Lite"/>
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Freeing Candidates"/>
<link href="#rfc.section.7.3.1" rel="Chapter" title="7.3.1 Full Implementation Procedures"/>
<link href="#rfc.section.7.3.2" rel="Chapter" title="7.3.2 Lite Implementation Procedures"/>
<link href="#rfc.section.8" rel="Chapter" title="8 ICE Restarts"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Keepalives"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Media Handling"/>
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Sending Media"/>
<link href="#rfc.section.10.1.1" rel="Chapter" title="10.1.1 Procedures for Full Implementations"/>
<link href="#rfc.section.10.1.2" rel="Chapter" title="10.1.2 Procedures for Lite Implementations"/>
<link href="#rfc.section.10.1.3" rel="Chapter" title="10.1.3 Procedures for All Implementations"/>
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Receiving Media"/>
<link href="#rfc.section.11" rel="Chapter" title="11 Extensibility Considerations"/>
<link href="#rfc.section.12" rel="Chapter" title="12 Setting Ta and RTO"/>
<link href="#rfc.section.12.1" rel="Chapter" title="12.1 Real-time Media Streams"/>
<link href="#rfc.section.12.2" rel="Chapter" title="12.2 Non-real-time Sessions"/>
<link href="#rfc.section.13" rel="Chapter" title="13 Example"/>
<link href="#rfc.section.14" rel="Chapter" title="14 Security Considerations"/>
<link href="#rfc.section.14.1" rel="Chapter" title="14.1 Attacks on Connectivity Checks"/>
<link href="#rfc.section.14.2" rel="Chapter" title="14.2 Attacks on Server Reflexive Address Gathering"/>
<link href="#rfc.section.14.3" rel="Chapter" title="14.3 Attacks on Relayed Candidate Gathering"/>
<link href="#rfc.section.14.4" rel="Chapter" title="14.4 Insider Attacks"/>
<link href="#rfc.section.14.4.1" rel="Chapter" title="14.4.1 STUN Amplification Attack"/>
<link href="#rfc.section.15" rel="Chapter" title="15 STUN Extensions"/>
<link href="#rfc.section.15.1" rel="Chapter" title="15.1 New Attributes"/>
<link href="#rfc.section.15.2" rel="Chapter" title="15.2 New Error Response Codes"/>
<link href="#rfc.section.16" rel="Chapter" title="16 Operational Considerations"/>
<link href="#rfc.section.16.1" rel="Chapter" title="16.1 NAT and Firewall Types"/>
<link href="#rfc.section.16.2" rel="Chapter" title="16.2 Bandwidth Requirements"/>
<link href="#rfc.section.16.2.1" rel="Chapter" title="16.2.1 STUN and TURN Server Capacity Planning"/>
<link href="#rfc.section.16.2.2" rel="Chapter" title="16.2.2 Gathering and Connectivity Checks"/>
<link href="#rfc.section.16.2.3" rel="Chapter" title="16.2.3 Keepalives"/>
<link href="#rfc.section.16.3" rel="Chapter" title="16.3 ICE and ICE-lite"/>
<link href="#rfc.section.16.4" rel="Chapter" title="16.4 Troubleshooting and Performance Management"/>
<link href="#rfc.section.16.5" rel="Chapter" title="16.5 Endpoint Configuration"/>
<link href="#rfc.section.17" rel="Chapter" title="17 IANA Considerations"/>
<link href="#rfc.section.17.1" rel="Chapter" title="17.1 STUN Attributes"/>
<link href="#rfc.section.17.2" rel="Chapter" title="17.2 STUN Error Responses"/>
<link href="#rfc.section.18" rel="Chapter" title="18 IAB Considerations"/>
<link href="#rfc.section.18.1" rel="Chapter" title="18.1 Problem Definition"/>
<link href="#rfc.section.18.2" rel="Chapter" title="18.2 Exit Strategy"/>
<link href="#rfc.section.18.3" rel="Chapter" title="18.3 Brittleness Introduced by ICE"/>
<link href="#rfc.section.18.4" rel="Chapter" title="18.4 Requirements for a Long-Term Solution"/>
<link href="#rfc.section.18.5" rel="Chapter" title="18.5 Issues with Existing NAPT Boxes"/>
<link href="#rfc.section.19" rel="Chapter" title="19 Changes from RFC 5245"/>
<link href="#rfc.section.20" rel="Chapter" title="20 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="21 References"/>
<link href="#rfc.references.1" rel="Chapter" title="21.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="21.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Lite and Full Implementations"/>
<link href="#rfc.appendix.B" rel="Chapter" title="B Design Motivations"/>
<link href="#rfc.appendix.B.1" rel="Chapter" title="B.1 Pacing of STUN Transactions"/>
<link href="#rfc.appendix.B.2" rel="Chapter" title="B.2 Candidates with Multiple Bases"/>
<link href="#rfc.appendix.B.3" rel="Chapter" title="B.3 Purpose of the Related Address and Related Port Attributes"/>
<link href="#rfc.appendix.B.4" rel="Chapter" title="B.4 Importance of the STUN Username"/>
<link href="#rfc.appendix.B.5" rel="Chapter" title="B.5 The Candidate Pair Priority Formula"/>
<link href="#rfc.appendix.B.6" rel="Chapter" title="B.6 Why Are Keepalives Needed?"/>
<link href="#rfc.appendix.B.7" rel="Chapter" title="B.7 Why Prefer Peer Reflexive Candidates?"/>
<link href="#rfc.appendix.B.8" rel="Chapter" title="B.8 Why Are Binding Indications Used for Keepalives?"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.0 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Keranen, A., Holmberg, C., and J. Rosenberg" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-ice-rfc5245bis-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2016-2-16" />
  <meta name="dct.abstract" content="This document describes a protocol for Network Address Translator (NAT) traversal for UDP-based multimedia. This protocol is called Interactive Connectivity Establishment (ICE). ICE makes use of the Session Traversal Utilities for NAT (STUN) protocol and its extension, Traversal Using Relay NAT (TURN)." />
  <meta name="description" content="This document describes a protocol for Network Address Translator (NAT) traversal for UDP-based multimedia. This protocol is called Interactive Connectivity Establishment (ICE). ICE makes use of the Session Traversal Utilities for NAT (STUN) protocol and its extension, Traversal Using Relay NAT (TURN)." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">ICE</td>
  <td class="right">A. Keranen</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">C. Holmberg</td>
</tr>
<tr>
  <td class="left">Obsoletes: 5245 (if approved)</td>
  <td class="right">Ericsson</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">J. Rosenberg</td>
</tr>
<tr>
  <td class="left">Expires: August 19, 2016</td>
  <td class="right">jdrosen.net</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">February 16, 2016</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal <br />
  <span class="filename">draft-ietf-ice-rfc5245bis-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document describes a protocol for Network Address Translator (NAT) traversal for UDP-based multimedia. This protocol is called Interactive Connectivity Establishment (ICE). ICE makes use of the Session Traversal Utilities for NAT (STUN) protocol and its extension, Traversal Using Relay NAT (TURN).</p>
<p>This document obsoletes RFC 5245. </p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 19, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2016 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>
<p>This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008.  The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Overview of ICE</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Gathering Candidate Addresses</a></li>
<li>2.2.   <a href="#rfc.section.2.2">Connectivity Checks</a></li>
<li>2.3.   <a href="#rfc.section.2.3">Sorting Candidates</a></li>
<li>2.4.   <a href="#rfc.section.2.4">Frozen Candidates</a></li>
<li>2.5.   <a href="#rfc.section.2.5">Security for Checks</a></li>
<li>2.6.   <a href="#rfc.section.2.6">Concluding ICE</a></li>
<li>2.7.   <a href="#rfc.section.2.7">Lite Implementations</a></li>
<li>2.8.   <a href="#rfc.section.2.8">Usages of ICE</a></li>
</ul><li>3.   <a href="#rfc.section.3">Terminology</a></li>
<li>4.   <a href="#rfc.section.4">ICE Candidate Gathering and Exchange</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Procedures for Full Implementation</a></li>
<ul><li>4.1.1.   <a href="#rfc.section.4.1.1">Gathering Candidates</a></li>
<ul><li>4.1.1.1.   <a href="#rfc.section.4.1.1.1">Host Candidates</a></li>
<li>4.1.1.2.   <a href="#rfc.section.4.1.1.2">Server Reflexive and Relayed Candidates</a></li>
<li>4.1.1.3.   <a href="#rfc.section.4.1.1.3">Computing Foundations</a></li>
<li>4.1.1.4.   <a href="#rfc.section.4.1.1.4">Keeping Candidates Alive</a></li>
</ul><li>4.1.2.   <a href="#rfc.section.4.1.2">Prioritizing Candidates</a></li>
<ul><li>4.1.2.1.   <a href="#rfc.section.4.1.2.1">Recommended Formula</a></li>
<li>4.1.2.2.   <a href="#rfc.section.4.1.2.2">Guidelines for Choosing Type and Local Preferences</a></li>
</ul><li>4.1.3.   <a href="#rfc.section.4.1.3">Eliminating Redundant Candidates</a></li>
</ul><li>4.2.   <a href="#rfc.section.4.2">Lite Implementation Procedures</a></li>
<li>4.3.   <a href="#rfc.section.4.3">Encoding the Candidate Information</a></li>
</ul><li>5.   <a href="#rfc.section.5">ICE Candidate Processing</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Procedures for Full Implementation</a></li>
<ul><li>5.1.1.   <a href="#rfc.section.5.1.1">Verifying ICE Support</a></li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">Determining Role</a></li>
<li>5.1.3.   <a href="#rfc.section.5.1.3">Forming the Check Lists</a></li>
<ul><li>5.1.3.1.   <a href="#rfc.section.5.1.3.1">Forming Candidate Pairs</a></li>
<li>5.1.3.2.   <a href="#rfc.section.5.1.3.2">Computing Pair Priority and Ordering Pairs</a></li>
<li>5.1.3.3.   <a href="#rfc.section.5.1.3.3">Pruning the Pairs</a></li>
<li>5.1.3.4.   <a href="#rfc.section.5.1.3.4">Computing States</a></li>
</ul><li>5.1.4.   <a href="#rfc.section.5.1.4">Scheduling Checks</a></li>
</ul><li>5.2.   <a href="#rfc.section.5.2">Lite Implementation Procedures</a></li>
</ul><li>6.   <a href="#rfc.section.6">Performing Connectivity Checks</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">STUN Client Procedures</a></li>
<ul><li>6.1.1.   <a href="#rfc.section.6.1.1">Creating Permissions for Relayed Candidates</a></li>
<li>6.1.2.   <a href="#rfc.section.6.1.2">Sending the Request</a></li>
<ul><li>6.1.2.1.   <a href="#rfc.section.6.1.2.1">PRIORITY and USE-CANDIDATE</a></li>
<li>6.1.2.2.   <a href="#rfc.section.6.1.2.2">ICE-CONTROLLED and ICE-CONTROLLING</a></li>
<li>6.1.2.3.   <a href="#rfc.section.6.1.2.3">Forming Credentials</a></li>
<li>6.1.2.4.   <a href="#rfc.section.6.1.2.4">DiffServ Treatment</a></li>
</ul><li>6.1.3.   <a href="#rfc.section.6.1.3">Processing the Response</a></li>
<ul><li>6.1.3.1.   <a href="#rfc.section.6.1.3.1">Failure Cases</a></li>
<li>6.1.3.2.   <a href="#rfc.section.6.1.3.2">Success Cases</a></li>
<ul><li>6.1.3.2.1.   <a href="#rfc.section.6.1.3.2.1">Discovering Peer Reflexive Candidates</a></li>
<li>6.1.3.2.2.   <a href="#rfc.section.6.1.3.2.2">Constructing a Valid Pair</a></li>
<li>6.1.3.2.3.   <a href="#rfc.section.6.1.3.2.3">Updating Pair States</a></li>
<li>6.1.3.2.4.   <a href="#rfc.section.6.1.3.2.4">Updating the Nominated Flag</a></li>
</ul><li>6.1.3.3.   <a href="#rfc.section.6.1.3.3">Check List and Timer State Updates</a></li>
</ul></ul><li>6.2.   <a href="#rfc.section.6.2">STUN Server Procedures</a></li>
<ul><li>6.2.1.   <a href="#rfc.section.6.2.1">Additional Procedures for Full Implementations</a></li>
<ul><li>6.2.1.1.   <a href="#rfc.section.6.2.1.1">Detecting and Repairing Role Conflicts</a></li>
<li>6.2.1.2.   <a href="#rfc.section.6.2.1.2">Computing Mapped Address</a></li>
<li>6.2.1.3.   <a href="#rfc.section.6.2.1.3">Learning Peer Reflexive Candidates</a></li>
<li>6.2.1.4.   <a href="#rfc.section.6.2.1.4">Triggered Checks</a></li>
<li>6.2.1.5.   <a href="#rfc.section.6.2.1.5">Updating the Nominated Flag</a></li>
</ul><li>6.2.2.   <a href="#rfc.section.6.2.2">Additional Procedures for Lite Implementations</a></li>
</ul></ul><li>7.   <a href="#rfc.section.7">Concluding ICE Processing</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Procedures for Full Implementations</a></li>
<ul><li>7.1.1.   <a href="#rfc.section.7.1.1">Nominating Pairs</a></li>
<ul><li>7.1.1.1.   <a href="#rfc.section.7.1.1.1">Regular Nomination</a></li>
<li>7.1.1.2.   <a href="#rfc.section.7.1.1.2">Aggressive Nomination</a></li>
</ul><li>7.1.2.   <a href="#rfc.section.7.1.2">Updating States</a></li>
</ul><li>7.2.   <a href="#rfc.section.7.2">Procedures for Lite Implementations</a></li>
<ul><li>7.2.1.   <a href="#rfc.section.7.2.1">Peer Is Full</a></li>
<li>7.2.2.   <a href="#rfc.section.7.2.2">Peer Is Lite</a></li>
</ul><li>7.3.   <a href="#rfc.section.7.3">Freeing Candidates</a></li>
<ul><li>7.3.1.   <a href="#rfc.section.7.3.1">Full Implementation Procedures</a></li>
<li>7.3.2.   <a href="#rfc.section.7.3.2">Lite Implementation Procedures</a></li>
</ul></ul><li>8.   <a href="#rfc.section.8">ICE Restarts</a></li>
<li>9.   <a href="#rfc.section.9">Keepalives</a></li>
<li>10.   <a href="#rfc.section.10">Media Handling</a></li>
<ul><li>10.1.   <a href="#rfc.section.10.1">Sending Media</a></li>
<ul><li>10.1.1.   <a href="#rfc.section.10.1.1">Procedures for Full Implementations</a></li>
<li>10.1.2.   <a href="#rfc.section.10.1.2">Procedures for Lite Implementations</a></li>
<li>10.1.3.   <a href="#rfc.section.10.1.3">Procedures for All Implementations</a></li>
</ul><li>10.2.   <a href="#rfc.section.10.2">Receiving Media</a></li>
</ul><li>11.   <a href="#rfc.section.11">Extensibility Considerations</a></li>
<li>12.   <a href="#rfc.section.12">Setting Ta and RTO</a></li>
<ul><li>12.1.   <a href="#rfc.section.12.1">Real-time Media Streams</a></li>
<li>12.2.   <a href="#rfc.section.12.2">Non-real-time Sessions</a></li>
</ul><li>13.   <a href="#rfc.section.13">Example</a></li>
<li>14.   <a href="#rfc.section.14">Security Considerations</a></li>
<ul><li>14.1.   <a href="#rfc.section.14.1">Attacks on Connectivity Checks</a></li>
<li>14.2.   <a href="#rfc.section.14.2">Attacks on Server Reflexive Address Gathering</a></li>
<li>14.3.   <a href="#rfc.section.14.3">Attacks on Relayed Candidate Gathering</a></li>
<li>14.4.   <a href="#rfc.section.14.4">Insider Attacks</a></li>
<ul><li>14.4.1.   <a href="#rfc.section.14.4.1">STUN Amplification Attack</a></li>
</ul></ul><li>15.   <a href="#rfc.section.15">STUN Extensions</a></li>
<ul><li>15.1.   <a href="#rfc.section.15.1">New Attributes</a></li>
<li>15.2.   <a href="#rfc.section.15.2">New Error Response Codes</a></li>
</ul><li>16.   <a href="#rfc.section.16">Operational Considerations</a></li>
<ul><li>16.1.   <a href="#rfc.section.16.1">NAT and Firewall Types</a></li>
<li>16.2.   <a href="#rfc.section.16.2">Bandwidth Requirements</a></li>
<ul><li>16.2.1.   <a href="#rfc.section.16.2.1">STUN and TURN Server Capacity Planning</a></li>
<li>16.2.2.   <a href="#rfc.section.16.2.2">Gathering and Connectivity Checks</a></li>
<li>16.2.3.   <a href="#rfc.section.16.2.3">Keepalives</a></li>
</ul><li>16.3.   <a href="#rfc.section.16.3">ICE and ICE-lite</a></li>
<li>16.4.   <a href="#rfc.section.16.4">Troubleshooting and Performance Management</a></li>
<li>16.5.   <a href="#rfc.section.16.5">Endpoint Configuration</a></li>
</ul><li>17.   <a href="#rfc.section.17">IANA Considerations</a></li>
<ul><li>17.1.   <a href="#rfc.section.17.1">STUN Attributes</a></li>
<li>17.2.   <a href="#rfc.section.17.2">STUN Error Responses</a></li>
</ul><li>18.   <a href="#rfc.section.18">IAB Considerations</a></li>
<ul><li>18.1.   <a href="#rfc.section.18.1">Problem Definition</a></li>
<li>18.2.   <a href="#rfc.section.18.2">Exit Strategy</a></li>
<li>18.3.   <a href="#rfc.section.18.3">Brittleness Introduced by ICE</a></li>
<li>18.4.   <a href="#rfc.section.18.4">Requirements for a Long-Term Solution</a></li>
<li>18.5.   <a href="#rfc.section.18.5">Issues with Existing NAPT Boxes</a></li>
</ul><li>19.   <a href="#rfc.section.19">Changes from RFC 5245</a></li>
<li>20.   <a href="#rfc.section.20">Acknowledgements</a></li>
<li>21.   <a href="#rfc.references">References</a></li>
<ul><li>21.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>21.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Lite and Full Implementations</a></li>
<li>Appendix B.   <a href="#rfc.appendix.B">Design Motivations</a></li>
<ul><li>B.1.   <a href="#rfc.appendix.B.1">Pacing of STUN Transactions</a></li>
<li>B.2.   <a href="#rfc.appendix.B.2">Candidates with Multiple Bases</a></li>
<li>B.3.   <a href="#rfc.appendix.B.3">Purpose of the Related Address and Related Port Attributes</a></li>
<li>B.4.   <a href="#rfc.appendix.B.4">Importance of the STUN Username</a></li>
<li>B.5.   <a href="#rfc.appendix.B.5">The Candidate Pair Priority Formula</a></li>
<li>B.6.   <a href="#rfc.appendix.B.6">Why Are Keepalives Needed?</a></li>
<li>B.7.   <a href="#rfc.appendix.B.7">Why Prefer Peer Reflexive Candidates?</a></li>
<li>B.8.   <a href="#rfc.appendix.B.8">Why Are Binding Indications Used for Keepalives?</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">Protocols establishing multimedia sessions between peers typically involve exchanging IP addresses and ports for the media sources and sinks. However this poses challenges when operated through Network Address Translators (NATs) <a href="#RFC3235">[RFC3235]</a>. These protocols also seek to create a media flow directly between participants, so that there is no application layer intermediary between them.  This is done to reduce media latency, decrease packet loss, and reduce the operational costs of deploying the application.  However, this is difficult to accomplish through NAT.  A full treatment of the reasons for this is beyond the scope of this specification.  </p>
<p id="rfc.section.1.p.2">Numerous solutions have been defined for allowing these protocols to operate through NAT. These include Application Layer Gateways (ALGs), the <a href="#RFC3303">Middlebox Control Protocol</a> <cite title="NONE">[RFC3303]</cite>, the original <a href="#RFC3489">Simple Traversal of UDP Through NAT (STUN)</a> <cite title="NONE">[RFC3489]</cite> specification, and <a href="#RFC3102">Realm Specific IP</a> <cite title="NONE">[RFC3102]</cite> <a href="#RFC3103">[RFC3103]</a> along with session description extensions needed to make them work, such as the Session Description Protocol (SDP) <a href="#RFC4566">[RFC4566]</a> attribute for the Real Time Control Protocol (RTCP) <a href="#RFC3605">[RFC3605]</a>. Unfortunately, these techniques all have pros and cons which, make each one optimal in some network topologies, but a poor choice in others. The result is that administrators and implementors are making assumptions about the topologies of the networks in which their solutions will be deployed. This introduces complexity and brittleness into the system. What is needed is a single solution that is flexible enough to work well in all situations.  </p>
<p id="rfc.section.1.p.3">This specification defines Interactive Connectivity Establishment (ICE) as a technique for NAT traversal for UDP-based media streams (though ICE has been extended to handle other transport protocols, such as TCP <a href="#RFC6544">[RFC6544]</a>). ICE works by exchanging a multiplicity of IP addresses and ports which are then tested for connectivity by peer-to-peer connectivity checks. The IP addresses and ports are exchanged via mechanisms (for example, including in a offer/answer exchange) and the connectivity checks are performed using Session Traversal Utilities for NAT (STUN) specification <a href="#RFC5389">[RFC5389]</a>. ICE also makes use of Traversal Using Relays around NAT (TURN) <a href="#RFC5766">[RFC5766]</a>, an extension to STUN.  Because ICE exchanges a multiplicity of IP addresses and ports for each media stream, it also allows for address selection for multihomed and dual-stack hosts, and for this reason it deprecates <a href="#RFC4091">[RFC4091]</a> and <a href="#RFC4092">[RFC4092]</a>.  </p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> Overview of ICE</h1>
<p id="rfc.section.2.p.1">In a typical ICE deployment, we have two endpoints (known as ICE AGENTS) that want to communicate.  They are able to communicate indirectly via some signaling protocol (such as SIP), by which they can exchange ICE candidates. Note that ICE is not intended for NAT traversal for the signaling protocol, which is assumed to be provided via another mechanism. At the beginning of the ICE process, the agents are ignorant of their own topologies.  In particular, they might or might not be behind a NAT (or multiple tiers of NATs). ICE allows the agents to discover enough information about their topologies to potentially find one or more paths by which they can communicate.  </p>
<p><a href="#fig-ice-ref-arch">Figure 1</a> shows a typical environment for ICE deployment. The two endpoints are labelled L and R (for left and right, which helps visualize call flows). Both L and R are behind their own respective NATs though they may not be aware of it. The type of NAT and its properties are also unknown. Agents L and R are capable of engaging in an candidate exchange process, whose purpose is to set up a media session between L and R. Typically, this exchange will occur through a signaling (e.g., SIP) server.  </p>
<p id="rfc.section.2.p.3">In addition to the agents, a signaling server and NATs, ICE is typically used in concert with STUN or TURN servers in the network. Each agent can have its own STUN or TURN server, or they can be the same.  </p>
<div id="rfc.figure.1"/>
<div id="fig-ice-ref-arch"/>
<pre>

                  +---------+
+--------+        |Signaling|         +--------+
| STUN   |        |Server   |         | STUN   |
| Server |        +---------+         | Server |
+--------+       /           \        +--------+
                /             \
               /               \
              / &lt;- Signaling -&gt; \
             /                   \
      +--------+               +--------+
      |  NAT   |               |  NAT   |
      +--------+               +--------+
        /                             \
       /                               \
   +-------+                       +-------+
   | Agent |                       | Agent |
   |   L   |                       |   R   |
   +-------+                       +-------+
</pre>
<p class="figure">Figure 1: ICE Deployment Scenario</p>
<p id="rfc.section.2.p.4">The basic idea behind ICE is as follows: each agent has a variety of candidate TRANSPORT ADDRESSES (combination of IP address and port for a particular transport protocol, which is always UDP in this specification) it could use to communicate with the other agent. These might include: </p>

<ul>
  <li>A transport address on a directly attached network interface</li>
  <li>A translated transport address on the public side of a NAT (a "server reflexive" address)</li>
  <li>A transport address allocated from a TURN server (a "relayed address")</li>
</ul>

<p> </p>
<p id="rfc.section.2.p.5">Potentially, any of L's candidate transport addresses can be used to communicate with any of R's candidate transport addresses. In practice, however, many combinations will not work. For instance, if L and R are both behind NATs, their directly attached interface addresses are unlikely to be able to communicate directly (this is why ICE is needed, after all!). The purpose of ICE is to discover which pairs of addresses will work.  The way that ICE does this is to systematically try all possible pairs (in a carefully sorted order) until it finds one or more that work.  </p>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> Gathering Candidate Addresses</h1>
<p id="rfc.section.2.1.p.1">In order to execute ICE, an agent has to identify all of its address candidates. A CANDIDATE is a transport address -- a combination of IP address and port for a particular transport protocol (with only UDP specified here). This document defines three types of candidates, some derived from physical or logical network interfaces, others discoverable via STUN and TURN.  Naturally, one viable candidate is a transport address obtained directly from a local interface. Such a candidate is called a HOST CANDIDATE. The local interface could be Ethernet or WiFi, or it could be one that is obtained through a tunnel mechanism, such as a Virtual Private Network (VPN) or Mobile IP (MIP). In all cases, such a network interface appears to the agent as a local interface from which ports (and thus candidates) can be allocated.  </p>
<p id="rfc.section.2.1.p.2">If an agent is multihomed, it obtains a candidate from each IP address. Depending on the location of the PEER (the other agent in the session) on the IP network relative to the agent, the agent may be reachable by the peer through one or more of those IP addresses. Consider, for example, an agent that has a local IP address on a private net 10 network (I1), and a second connected to the public Internet (I2). A candidate from I1 will be directly reachable when communicating with a peer on the same private net 10 network, while a candidate from I2 will be directly reachable when communicating with a peer on the public Internet. Rather than trying to guess which IP address will work, the initiating sends both the candidates to its peer.  </p>
<p id="rfc.section.2.1.p.3">Next, the agent uses STUN or TURN to obtain additional candidates. These come in two flavors: translated addresses on the public side of a NAT (SERVER REFLEXIVE CANDIDATES) and addresses on TURN servers (RELAYED CANDIDATES). When TURN servers are utilized, both types of candidates are obtained from the TURN server. If only STUN servers are utilized, only server reflexive candidates are obtained from them.  The relationship of these candidates to the host candidate is shown in <a href="#fig-address-types">Figure 2</a>.  In this figure, both types of candidates are discovered using TURN. In the figure, the notation X:x means IP address X and UDP port x.  </p>
<div id="rfc.figure.2"/>
<div id="fig-address-types"/>
<pre>


              To Internet

                  |
                  |
                  |  /------------  Relayed
              Y:y | /               Address
              +--------+
              |        |
              |  TURN  |
              | Server |
              |        |
              +--------+
                  |
                  |
                  | /------------  Server
           X1':x1'|/               Reflexive
            +------------+         Address
            |    NAT     |
            +------------+
                  |
                  | /------------  Local
              X:x |/               Address
              +--------+
              |        |
              | Agent  |
              |        |
              +--------+

</pre>
<p class="figure">Figure 2: Candidate Relationships</p>
<p id="rfc.section.2.1.p.4">When the agent sends the TURN Allocate request from IP address and port X:x, the NAT (assuming there is one) will create a binding X1':x1', mapping this server reflexive candidate to the host candidate X:x. Outgoing packets sent from the host candidate will be translated by the NAT to the server reflexive candidate.  Incoming packets sent to the server reflexive candidate will be translated by the NAT to the host candidate and forwarded to the agent. We call the host candidate associated with a given server reflexive candidate the BASE.  </p>
<p/>

<ul class="empty">
  <li>Note: "Base" refers to the address an agent sends from for a particular candidate. Thus, as a degenerate case host candidates also have a base, but it's the same as the host candidate.  </li>
</ul>
<p id="rfc.section.2.1.p.6">When there are multiple NATs between the agent and the TURN server, the TURN request will create a binding on each NAT, but only the outermost server reflexive candidate (the one nearest the TURN server) will be discovered by the agent. If the agent is not behind a NAT, then the base candidate will be the same as the server reflexive candidate and the server reflexive candidate is redundant and will be eliminated.  </p>
<p id="rfc.section.2.1.p.7">The Allocate request then arrives at the TURN server. The TURN server allocates a port y from its local IP address Y, and generates an Allocate response, informing the agent of this relayed candidate. The TURN server also informs the agent of the server reflexive candidate, X1':x1' by copying the source transport address of the Allocate request into the Allocate response. The TURN server acts as a packet relay, forwarding traffic between L and R. In order to send traffic to L, R sends traffic to the TURN server at Y:y, and the TURN server forwards that to X1':x1', which passes through the NAT where it is mapped to X:x and delivered to L.  </p>
<p id="rfc.section.2.1.p.8">When only STUN servers are utilized, the agent sends a STUN Binding request <a href="#RFC5389">[RFC5389]</a> to its STUN server. The STUN server will inform the agent of the server reflexive candidate X1':x1' by copying the source transport address of the Binding request into the Binding response.  </p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> Connectivity Checks</h1>
<p id="rfc.section.2.2.p.1">Once L has gathered all of its candidates, it orders them in highest to lowest-priority and sends them to R over the signaling channel. When R receives the candidates from L, it performs the same gathering process and responds with its own list of candidates. At the end of this process, each agent has a complete list of both its candidates and its peer's candidates. It pairs them up, resulting in CANDIDATE PAIRS.  To see which pairs work, each agent schedules a series of CHECKS. Each check is a STUN request/response transaction that the client will perform on a particular candidate pair by sending a STUN request from the local candidate to the remote candidate.  </p>
<p id="rfc.section.2.2.p.2">The basic principle of the connectivity checks is simple: </p>

<ol>
  <li>Sort the candidate pairs in priority order.</li>
  <li>Send checks on each candidate pair in priority order.</li>
  <li>Acknowledge checks received from the other agent.</li>
</ol>

<p> With both agents performing a check on a candidate pair, the result is a 4-way handshake: </p>
<div id="rfc.figure.3"/>
<div id="fig:connectivity-checks"/>
<pre>

L                        R
-                        -
STUN request -&gt;             \  L's
          &lt;- STUN response  /  check

           &lt;- STUN request  \  R's
STUN response -&gt;            /  check
</pre>
<p class="figure">Figure 3: Basic Connectivity Check</p>
<p id="rfc.section.2.2.p.3">It is important to note that the STUN requests are sent to and from the exact same IP addresses and ports that will be used for media (e.g., RTP and RTCP). Consequently, agents demultiplex STUN and RTP/RTCP using contents of the packets, rather than the port on which they are received. Fortunately, this demultiplexing is easy to do, especially for RTP and RTCP.  </p>
<p id="rfc.section.2.2.p.4">Because a STUN Binding request is used for the connectivity check, the STUN Binding response will contain the agent's translated transport address on the public side of any NATs between the agent and its peer. If this transport address is different from other candidates the agent already learned, it represents a new candidate, called a PEER REFLEXIVE CANDIDATE, which then gets tested by ICE just the same as any other candidate.  </p>
<p id="rfc.section.2.2.p.5">As an optimization, as soon as R gets L's check message, R schedules a connectivity check message to be sent to L on the same candidate pair. This accelerates the process of finding a valid candidate, and is called a TRIGGERED CHECK.  </p>
<p id="rfc.section.2.2.p.6">At the end of this handshake, both L and R know that they can send (and receive) messages end-to-end in both directions.  </p>
<h1 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a> Sorting Candidates</h1>
<p id="rfc.section.2.3.p.1">Because the algorithm above searches all candidate pairs, if a working pair exists it will eventually find it no matter what order the candidates are tried in. In order to produce faster (and better) results, the candidates are sorted in a specified order. The resulting list of sorted candidate pairs is called the CHECK LIST. The algorithm is described in <a href="#sec-prioritizing">Section 4.1.2</a> but follows two general principles: </p>

<ul>
  <li>Each agent gives its candidates a numeric priority, which is sent along with the candidate to the peer.</li>
  <li>The local and remote priorities are combined so that each agent has the same ordering for the candidate pairs.</li>
</ul>

<p> </p>
<p id="rfc.section.2.3.p.2">The second property is important for getting ICE to work when there are NATs in front of L and R. Frequently, NATs will not allow packets in from a host until the agent behind the NAT has sent a packet towards that host. Consequently, ICE checks in each direction will not succeed until both sides have sent a check through their respective NATs.  </p>
<p id="rfc.section.2.3.p.3">The agent works through this check list by sending a STUN request for the next candidate pair on the list periodically. These are called ORDINARY CHECKS.  </p>
<p id="rfc.section.2.3.p.4">In general, the priority algorithm is designed so that candidates of similar type get similar priorities and so that more direct routes (that is, through fewer media relays and through fewer NATs) are preferred over indirect ones (ones with more media relays and more NATs).  Within those guidelines, however, agents have a fair amount of discretion about how to tune their algorithms.  </p>
<h1 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4.</a> Frozen Candidates</h1>
<p id="rfc.section.2.4.p.1">The previous description only addresses the case where the agents wish to establish a media session with one COMPONENT (a piece of a media stream requiring a single transport address; a media stream may require multiple components, each of which has to work for the media stream as a whole to be work). Sometimes (e.g., with RTP and RTCP in separate components), the agents actually need to establish connectivity for more than one flow. </p>
<p id="rfc.section.2.4.p.2">The network properties are likely to be very similar for each component (especially because RTP and RTCP are sent and received from the same IP address). It is usually possible to leverage information from one media component in order to determine the best candidates for another. ICE does this with a mechanism called "frozen candidates".  </p>
<p id="rfc.section.2.4.p.3">Each candidate is associated with a property called its FOUNDATION. Two candidates have the same foundation when they are "similar" -- of the same type and obtained from the same host candidate and STUN/TURN server using the same protocol. Otherwise, their foundation is different. A candidate pair has a foundation too, which is just the concatenation of the foundations of its two candidates. Initially, only the candidate pairs with unique foundations are tested.  The other candidate pairs are marked "frozen". When the connectivity checks for a candidate pair succeed, the other candidate pairs with the same foundation are unfrozen. This avoids repeated checking of components that are superficially more attractive but in fact are likely to fail.  </p>
<p id="rfc.section.2.4.p.4">While we've described "frozen" here as a separate mechanism for expository purposes, in fact it is an integral part of ICE and the ICE prioritization algorithm automatically ensures that the right candidates are unfrozen and checked in the right order. However, if the ICE usage does not utilize multiple components or media streams, it does not need to implement this algorithm.  </p>
<h1 id="rfc.section.2.5"><a href="#rfc.section.2.5">2.5.</a> Security for Checks</h1>
<p id="rfc.section.2.5.p.1">Because ICE is used to discover which addresses can be used to send media between two agents, it is important to ensure that the process cannot be hijacked to send media to the wrong location. Each STUN connectivity check is covered by a message authentication code (MAC) computed using a key exchanged in the signaling channel. This MAC provides message integrity and data origin authentication, thus stopping an attacker from forging or modifying connectivity check messages. Furthermore, if for example a SIP <a href="#RFC3261">[RFC3261]</a> caller is using ICE, and their call forks, the ICE exchanges happen independently with each forked recipient. In such a case, the keys exchanged in the signaling help associate each ICE exchange with each forked recipient.  </p>
<h1 id="rfc.section.2.6"><a href="#rfc.section.2.6">2.6.</a> Concluding ICE</h1>
<p id="rfc.section.2.6.p.1">ICE checks are performed in a specific sequence, so that high-priority candidate pairs are checked first, followed by lower-priority ones. One way to conclude ICE is to declare victory as soon as a check for each component of each media stream completes successfully. Indeed, this is a reasonable algorithm, and details for it are provided below. However, it is possible that a packet loss will cause a higher-priority check to take longer to complete.  In that case, allowing ICE to run a little longer might produce better results. More fundamentally, however, the prioritization defined by this specification may not yield "optimal" results. As an example, if the aim is to select low-latency media paths, usage of a relay is a hint that latencies may be higher, but it is nothing more than a hint. An actual round-trip time (RTT) measurement could be made, and it might demonstrate that a pair with lower priority is actually better than one with higher priority.  </p>
<p id="rfc.section.2.6.p.2">Consequently, ICE assigns one of the agents in the role of the CONTROLLING AGENT, and the other of the CONTROLLED AGENT. The controlling agent gets to nominate which candidate pairs will get used for media amongst the ones that are valid. It can do this in one of two ways -- using REGULAR NOMINATION or AGGRESSIVE NOMINATION.  </p>
<p id="rfc.section.2.6.p.3">With regular nomination, the controlling agent lets the checks continue until at least one valid candidate pair for each media stream is found. Then, it picks amongst those that are valid, and sends a second STUN request on its NOMINATED candidate pair, but this time with a flag set to tell the peer that this pair has been nominated for use.  This is shown in <a href="#fig-regular-select">Figure 4</a>.  </p>
<div id="rfc.figure.4"/>
<div id="fig-regular-select"/>
<pre>

L                        R
-                        -
STUN request -&gt;             \  L's
          &lt;- STUN response  /  check

           &lt;- STUN request  \  R's
STUN response -&gt;            /  check

STUN request + flag -&gt;      \  L's
          &lt;- STUN response  /  check

</pre>
<p class="figure">Figure 4: Regular Nomination</p>
<p id="rfc.section.2.6.p.4">Once the STUN transaction with the flag completes, both sides cancel any future checks for that media stream. ICE will now send media using this pair. The pair an ICE agent is using for media is called the SELECTED PAIR.  </p>
<p id="rfc.section.2.6.p.5">In aggressive nomination, the controlling agent puts the flag in every connectivity check STUN request it sends. This way, once the first check succeeds, ICE processing is complete for that media stream and the controlling agent doesn't have to send a second STUN request. The selected pair will be the highest-priority valid pair whose check succeeded. Aggressive nomination is faster than regular nomination, but gives less flexibility. Aggressive nomination is shown in <a href="#fig-aggressive-select">Figure 5</a>.  </p>
<div id="rfc.figure.5"/>
<div id="fig-aggressive-select"/>
<pre>

L                        R
-                        -
STUN request + flag -&gt;      \  L's
          &lt;- STUN response  /  check

           &lt;- STUN request  \  R's
STUN response -&gt;            /  check

</pre>
<p class="figure">Figure 5: Aggressive Nomination</p>
<p id="rfc.section.2.6.p.6">Once ICE is concluded, it can be restarted at any time for one or all of the media streams by either agent. This is done by sending an updated candidate information indicating a restart.  </p>
<h1 id="rfc.section.2.7"><a href="#rfc.section.2.7">2.7.</a> Lite Implementations</h1>
<p id="rfc.section.2.7.p.1">In order for ICE to be used in a call, both agents need to support it.  However, certain agents will always be connected to the public Internet and have a public IP address at which it can receive packets from any correspondent. To make it easier for these devices to support ICE, ICE defines a special type of implementation called LITE (in contrast to the normal FULL implementation). A lite implementation doesn't gather candidates; it includes only host candidates for any media stream.  Lite agents do not generate connectivity checks or run the state machines, though they need to be able to respond to connectivity checks. When a lite implementation connects with a full implementation, the full agent takes the role of the controlling agent, and the lite agent takes on the controlled role. When two lite implementations connect, no checks are sent.  </p>
<p id="rfc.section.2.7.p.2">For guidance on when a lite implementation is appropriate, see the discussion in <a href="#sec-liteandfull">Appendix A</a>.  </p>
<p id="rfc.section.2.7.p.3">It is important to note that the lite implementation was added to this specification to provide a stepping stone to full implementation. Even for devices that are always connected to the public Internet, a full implementation is preferable if achievable.  </p>
<h1 id="rfc.section.2.8"><a href="#rfc.section.2.8">2.8.</a> Usages of ICE</h1>
<p id="rfc.section.2.8.p.1">This document specifies generic use of ICE with protocols that provide means to exchange candidate information between the ICE Peers.  The specific details of (i.e how to encode candidate information and the actual candidate exchange process) for different protocols using ICE are described in separate usage documents. One possible way the agents can exchange the candidate information is to use <a href="#RFC3264">[RFC3264]</a> based Offer/Answer semantics as part of the SIP <a href="#RFC3261">[RFC3261]</a> protocol <a href="#I-D.ietf-mmusic-ice-sip-sdp">[I-D.ietf-mmusic-ice-sip-sdp]</a>.  </p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> Terminology</h1>
<p id="rfc.section.3.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="NONE">[RFC2119]</cite>.  </p>
<p id="rfc.section.3.p.2">Readers should be familiar with the terminology defined in the STUN <a href="#RFC5389">[RFC5389]</a>, and NAT Behavioral requirements for UDP <a href="#RFC4787">[RFC4787]</a>.  </p>
<p id="rfc.section.3.p.3">This specification makes use of the following additional terminology: </p>
<p/>

<dl>
  <dt>ICE Agent:</dt>
  <dd style="margin-left: 8">An agent is the protocol implementation involved in the ICE candidate exchange.  There are two agents involved in a typical candidate exchange. </dd>
  <dt>Initiating Peer, Initiating Agent, Initiator:</dt>
  <dd style="margin-left: 8">An initiating agent is the protocol implementation involved in the ICE candidate exchange that initiates the ICE candidate exchange process. </dd>
  <dt>Responding Peer, Responding Agent, Responder:</dt>
  <dd style="margin-left: 8">A receiving agent is the protocol implementation involved in the ICE candidate exchange that receives and responds to the candidate exchange process initiated by the Initiator. </dd>
  <dt>ICE Candidate Exchange, Candidate Exchange:</dt>
  <dd style="margin-left: 8">The process where the ICE agents exchange information (e.g., candidates and passwords) that is needed to perform ICE.  <a href="#RFC3264">[RFC3264]</a> Offer/Answer with SDP encoding is one example of a protocol that can be used for exchanging the candidate information. </dd>
  <dt>Peer:</dt>
  <dd style="margin-left: 8">From the perspective of one of the agents in a session, its peer is the other agent. Specifically, from the perspective of the initiating agent, the peer is the responding agent.  From the perspective of the responding agent, the peer is the initiating agent. </dd>
  <dt>Transport Address:</dt>
  <dd style="margin-left: 8">The combination of an IP address and transport protocol (such as UDP or TCP) port.</dd>
  <dt>Media, Media Stream, Media Session:</dt>
  <dd style="margin-left: 8">When ICE is used to setup multimedia sessions, the media is usually transported over RTP, and a media stream composes of a stream of RTP packets. When ICE is used with other than multimedia sessions, the terms "media", "media stream", and "media session" are still used in this specification to refer to the IP data packets that are exchanged between the peers on the path created and tested with ICE. </dd>
  <dt>Candidate, Candidate Information:</dt>
  <dd style="margin-left: 8">A transport address that is a potential point of contact for receipt of media. Candidates also have properties -- their type (server reflexive, relayed, or host), priority,foundation, and base.  </dd>
  <dt>Component:</dt>
  <dd style="margin-left: 8">A component is a piece of a media stream requiring a single transport address; a media stream may require multiple components, each of which has to work for the media stream as a whole to work. For media streams based on RTP, unless RTP and RTCP are multiplexed in the same port, there are two components per media stream -- one for RTP, and one for RTCP. </dd>
  <dt>Host Candidate:</dt>
  <dd style="margin-left: 8">A candidate obtained by binding to a specific port from an IP address on the host. This includes IP addresses on physical interfaces and logical ones, such as ones obtained through Virtual Private Networks (VPNs) and Realm Specific IP (RSIP) <a href="#RFC3102">[RFC3102]</a> (which lives at the operating system level).  </dd>
  <dt>Server Reflexive Candidate:</dt>
  <dd style="margin-left: 8">A candidate whose IP address and port are a binding allocated by a NAT for an agent when it sent a packet through the NAT to a server. Server reflexive candidates can be learned by STUN servers using the Binding request, or TURN servers, which provides both a relayed and server reflexive candidate.  </dd>
  <dt>Peer Reflexive Candidate:</dt>
  <dd style="margin-left: 8">A candidate whose IP address and port are a binding allocated by a NAT for an agent when it sent a STUN Binding request through the NAT to its peer.  </dd>
  <dt>Relayed Candidate:</dt>
  <dd style="margin-left: 8">A candidate obtained by sending a TURN Allocate request from a host candidate to a TURN server. The relayed candidate is resident on the TURN server, and the TURN server relays packets back towards the agent.  </dd>
  <dt>Base:</dt>
  <dd style="margin-left: 8">The base of a server reflexive candidate is the host candidate from which it was derived. A host candidate is also said to have a base, equal to that candidate itself. Similarly, the base of a relayed candidate is that candidate itself.  </dd>
  <dt>Foundation:</dt>
  <dd style="margin-left: 8">An arbitrary string that is the same for two candidates that have the same type, base IP address, protocol (UDP, TCP, etc.), and STUN or TURN server.  If any of these are different, then the foundation will be different. Two candidate pairs with the same foundation pairs are likely to have similar network characteristics.  Foundations are used in the frozen algorithm.  </dd>
  <dt>Local Candidate:</dt>
  <dd style="margin-left: 8">A candidate that an agent has obtained and shared with the peer.  </dd>
  <dt>Remote Candidate:</dt>
  <dd style="margin-left: 8">A candidate that an agent received from its peer.  </dd>
  <dt>Default Destination/Candidate:</dt>
  <dd style="margin-left: 8">The default destination for a component of a media stream is the transport address that would be used by an agent that is not ICE aware.  A default candidate for a component is one whose transport address matches the default destination for that component.  </dd>
  <dt>Candidate Pair:</dt>
  <dd style="margin-left: 8">A pairing containing a local candidate and a remote candidate.  </dd>
  <dt>Check, Connectivity Check, STUN Check:</dt>
  <dd style="margin-left: 8">A STUN Binding request transaction for the purposes of verifying connectivity. A check is sent from the local candidate to the remote candidate of a candidate pair.  </dd>
  <dt>Check List:</dt>
  <dd style="margin-left: 8">An ordered set of candidate pairs that an agent will use to generate checks.  </dd>
  <dt>Ordinary Check:</dt>
  <dd style="margin-left: 8">A connectivity check generated by an agent as a consequence of a timer that fires periodically, instructing it to send a check.  </dd>
  <dt>Triggered Check:</dt>
  <dd style="margin-left: 8">A connectivity check generated as a consequence of the receipt of a connectivity check from the peer.  </dd>
  <dt>Valid List:</dt>
  <dd style="margin-left: 8">An ordered set of candidate pairs for a media stream that have been validated by a successful STUN transaction.  </dd>
  <dt>Full:</dt>
  <dd style="margin-left: 8">An ICE implementation that performs the complete set of functionality defined by this specification.  </dd>
  <dt>Lite:</dt>
  <dd style="margin-left: 8">An ICE implementation that omits certain functions, implementing only as much as is necessary for a peer implementation that is full to gain the benefits of ICE. Lite implementations do not maintain any of the state machines and do not generate connectivity checks.  </dd>
  <dt>Controlling Agent:</dt>
  <dd style="margin-left: 8">The ICE agent that is responsible for selecting the final choice of candidate pairs and signaling them through STUN. In any session, one agent is always controlling. The other is the controlled agent.  </dd>
  <dt>Controlled Agent:</dt>
  <dd style="margin-left: 8">An ICE agent that waits for the controlling agent to select the final choice of candidate pairs.  </dd>
  <dt>Regular Nomination:</dt>
  <dd style="margin-left: 8">The process of picking a valid candidate pair for media traffic by validating the pair with one STUN request, and then picking it by sending a second STUN request with a flag indicating its nomination.  </dd>
  <dt>Aggressive Nomination:</dt>
  <dd style="margin-left: 8">The process of picking a valid candidate pair for media traffic by including a flag in every connectivity check STUN request, such that the first one to produce a valid candidate pair is used for media.  </dd>
  <dt>Nominated:</dt>
  <dd style="margin-left: 8">If a valid candidate pair has its nominated flag set, it means that it may be selected by ICE for sending and receiving media.  </dd>
  <dt>Selected Pair, Selected Candidate:</dt>
  <dd style="margin-left: 8">The candidate pair selected by ICE for sending and receiving media is called the selected pair, and each of its candidates is called the selected candidate.  </dd>
  <dt>Using Protocol, ICE Usage:</dt>
  <dd style="margin-left: 8">The protocol that uses ICE for NAT traversal. A usage specification defines the protocol specific details on how the procedures defined here are applied to that protocol. </dd>
</dl>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#sec-gathering_exchange" id="sec-gathering_exchange">ICE Candidate Gathering and Exchange</a></h1>
<p id="rfc.section.4.p.1">As part of ICE processing, both the initiating and responding agents exchange encoded candidate information as defined by the Usage Protocol (ICE Usage). Specifics of encoding mechanism and the semantics of candidate information exchange is out of scope of this specification.  </p>
<p id="rfc.section.4.p.2">However at a higher level, the below diagram captures ICE processing sequence in the agents (initiator and responder) for exchange of their respective candidate(s) information.  </p>
<div id="rfc.figure.6"/>
<div id="fig:basic-cand-exchange"/>
<pre>

          Initiating                      Responding
            Agent                           Agent
            (I)                             (R)
Gather,      |                               |
prioritize,  |                               |
eliminate    |                               |
redundant    |                               |
candidates,  |                               |
Encode       |                               |
candidates   |                               |
             |   I's Candidate Information   |
             |------------------------------&gt;|
             |                               | Gather,
             |                               | prioritize,
             |                               | eliminate
             |                               | redundant
             |                               | candidates,
             |                               | Encode
             |                               | candidates
             |   R's Candidate Information   |
             |&lt;------------------------------|
             |                               |
</pre>
<p class="figure">Figure 6: Candidate Gathering and Exchange Sequence</p>
<p id="rfc.section.4.p.3">As shown, the agents involved in the candidate exchange perform (1) candidate gathering, (2) candidate prioritization, (3) eliminating redundant candidates, (4) (possibly) choose default candidates, and then (5) formulate and send the candidates to the Peer ICE agent. All but the last of these five steps differ for full and lite implementations.  </p>
<p/>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#sec-full-impl-reqs" id="sec-full-impl-reqs">Procedures for Full Implementation</a></h1>
<h1 id="rfc.section.4.1.1"><a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#sec-gathering" id="sec-gathering">Gathering Candidates</a></h1>
<p id="rfc.section.4.1.1.p.1">An agent gathers candidates when it believes that communication is imminent.  An initiating agent can do this based on a user interface cue, or based on an explicit request to initiate a session.  Every candidate is a transport address.  It also has a type and a base.  Four types are defined and gathered by this specification -- host candidates, server reflexive candidates, peer reflexive candidates, and relayed candidates.  The server reflexive candidates are gathered using STUN or TURN, and relayed candidates are obtained through TURN.  Peer reflexive candidates are obtained in later phases of ICE, as a consequence of connectivity checks.  The base of a candidate is the candidate that an agent must send from when using that candidate.  </p>
<p id="rfc.section.4.1.1.p.2">The process for gathering candidates at the responding agent is identical to the process for the initiating agent. It is RECOMMENDED that the responding agent begins this process immediately on receipt of the candidate information, prior to alerting the user. Such gathering MAY begin when an agent starts.  </p>
<h1 id="rfc.section.4.1.1.1"><a href="#rfc.section.4.1.1.1">4.1.1.1.</a> Host Candidates</h1>
<p id="rfc.section.4.1.1.1.p.1">The first step is to gather host candidates. Host candidates are obtained by binding to ports (typically ephemeral) on a IP address attached to an interface (physical or virtual, including VPN interfaces) on the host.  </p>
<p id="rfc.section.4.1.1.1.p.2">For each UDP media stream the agent wishes to use, the agent SHOULD obtain a candidate for each component of the media stream on each IP address that the host has, with the exceptions listed below. The agent obtains each candidate by binding to a UDP port on the specific IP address. A host candidate (and indeed every candidate) is always associated with a specific component for which it is a candidate. </p>
<p id="rfc.section.4.1.1.1.p.3">Each component has an ID assigned to it, called the component ID.  For RTP-based media streams, unless both RTP and RTCP are multiplexed in the same UDP port (RTP/RTCP multiplexing), the RTP itself has a component ID of 1, and RTCP a component ID of 2. In case of RTP/RTCP multiplexing, a component ID of 1 is used for both RTP and RTCP.</p>
<p id="rfc.section.4.1.1.1.p.4">When candidates are obtained, unless the agent knows for sure that RTP/RTCP multiplexing will be used (i.e. the agent knows that the other agent also supports, and is willing to use, RTP/RTCP multiplexing), or unless the agent only supports RTP/RTCP multiplexing, the agent MUST obtain a separate candidate for RTCP. If an agent has obtained a candidate for RTCP, and ends up using RTP/RTCP multiplexing, the agent does not need to perform connectivity checks on the RTCP candidate.</p>
<p id="rfc.section.4.1.1.1.p.5">If an agent is using separate candidates for RTP and RTCP, it will end up with 2*K host candidates if an agent has K IP addresses.</p>
<p id="rfc.section.4.1.1.1.p.6">Note that the responding agent, when obtaining its candidates, will typically know if the other agent supports RTP/RTCP multiplexing, in which case it will not need to obtain a separate candidate for RTCP. However, absence of a component ID 2 as such does not imply use of RTCP/RTP multiplexing, as it could also mean that RTCP is not used. </p>
<p id="rfc.section.4.1.1.1.p.7">For other than RTP-based streams, use of multiple components is discouraged since using them increases the complexity of ICE processing. If multiple components are needed, the component IDs SHOULD start with 1 and increase by 1 for each component.  </p>
<p id="rfc.section.4.1.1.1.p.8">The base for each host candidate is set to the candidate itself.  </p>
<p id="rfc.section.4.1.1.1.p.9">The host candidates are gathered from all IP addresses with the following exceptions: </p>

<ul>
  <li>Addresses from a loopback interface MUST NOT be included in the candidate addresses. </li>
  <li>Deprecated IPv4-compatible IPv6 addresses <a href="#RFC4291">[RFC4291]</a> and IPv6 site-local unicast addresses <a href="#RFC3879">[RFC3879]</a> MUST NOT be included in the address candidates. </li>
  <li>IPv4-mapped IPv6 addresses SHOULD NOT be included in the offered candidates unless the application using ICE does not support IPv4 (i.e., is an IPv6-only application <a href="#RFC4038">[RFC4038]</a>). </li>
  <li>If one or more host candidates corresponding to an IPv6 address generated using a mechanism that prevents location tracking <a href="#I-D.ietf-6man-ipv6-address-generation-privacy">[I-D.ietf-6man-ipv6-address-generation-privacy]</a> are gathered, host candidates corresponding to IPv6 addresses that do allow location tracking, that are configured on the same interface, and are part of the same network prefix MUST NOT be gathered; and host candidates corresponding to IPv6 link-local addresses MUST NOT be gathered.</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.1.1.2"><a href="#rfc.section.4.1.1.2">4.1.1.2.</a> Server Reflexive and Relayed Candidates</h1>
<p id="rfc.section.4.1.1.2.p.1">Agents SHOULD obtain relayed candidates and SHOULD obtain server reflexive candidates. These requirements are at SHOULD strength to allow for provider variation. Use of STUN and TURN servers may be unnecessary in closed networks where agents are never connected to the public Internet or to endpoints outside of the closed network. In such cases, a full implementation would be used for agents that are dual-stack or multihomed, to select a host candidate. Use of TURN servers is expensive, and when ICE is being used, they will only be utilized when both endpoints are behind NATs that perform address and port dependent mapping. Consequently, some deployments might consider this use case to be marginal, and elect not to use TURN servers. If an agent does not gather server reflexive or relayed candidates, it is RECOMMENDED that the functionality be implemented and just disabled through configuration, so that it can be re-enabled through configuration if conditions change in the future.  </p>
<p id="rfc.section.4.1.1.2.p.2">If an agent is gathering both relayed and server reflexive candidates, it uses a TURN server. If it is gathering just server reflexive candidates, it uses a STUN server.  </p>
<p id="rfc.section.4.1.1.2.p.3">The agent next pairs each host candidate with the STUN or TURN server with which it is configured or has discovered by some means. If a STUN or TURN server is configured, it is RECOMMENDED that a domain name be configured, and the DNS procedures in <a href="#RFC5389">[RFC5389]</a> (using SRV records with the "stun" service) be used to discover the STUN server, and the DNS procedures in <a href="#RFC5766">[RFC5766]</a> (using SRV records with the "turn" service) be used to discover the TURN server.  </p>
<p id="rfc.section.4.1.1.2.p.4">This specification only considers usage of a single STUN or TURN server. When there are multiple choices for that single STUN or TURN server (when, for example, they are learned through DNS records and multiple results are returned), an agent SHOULD use a single STUN or TURN server (based on its IP address) for all candidates for a particular session. This improves the performance of ICE. The result is a set of pairs of host candidates with STUN or TURN servers. The agent then chooses one pair, and sends a Binding or Allocate request to the server from that host candidate. Binding requests to a STUN server are not authenticated, and any ALTERNATE-SERVER attribute in a response is ignored. Agents MUST support the backwards compatibility mode for the Binding request defined in <a href="#RFC5389">[RFC5389]</a>. Allocate requests SHOULD be authenticated using a long-term credential obtained by the client through some other means.  </p>
<p id="rfc.section.4.1.1.2.p.5">Every Ta milliseconds thereafter, the agent can generate another new STUN or TURN transaction. This transaction can either be a retry of a previous transaction that failed with a recoverable error (such as authentication failure), or a transaction for a new host candidate and STUN or TURN server pair. The agent SHOULD NOT generate transactions more frequently than one every Ta milliseconds. See <a href="#sec-ta">Section 12</a> for guidance on how to set Ta and the STUN retransmit timer, RTO.  </p>
<p id="rfc.section.4.1.1.2.p.6">The agent will receive a Binding or Allocate response. A successful Allocate response will provide the agent with a server reflexive candidate (obtained from the mapped address) and a relayed candidate in the XOR-RELAYED-ADDRESS attribute. If the Allocate request is rejected because the server lacks resources to fulfill it, the agent SHOULD instead send a Binding request to obtain a server reflexive candidate. A Binding response will provide the agent with only a server reflexive candidate (also obtained from the mapped address). The base of the server reflexive candidate is the host candidate from which the Allocate or Binding request was sent. The base of a relayed candidate is that candidate itself. If a relayed candidate is identical to a host candidate (which can happen in rare cases), the relayed candidate MUST be discarded.  </p>
<p id="rfc.section.4.1.1.2.p.7">If an IPv6-only agent is in a network that utilizes NAT64 <a href="#RFC6146">[RFC6146]</a> and DNS64 <a href="#RFC6147">[RFC6147]</a> technologies, it may gather also IPv4 server reflexive and/or relayed candidates from IPv4-only STUN or TURN servers.  IPv6-only agents SHOULD also utilize IPv6 prefix discovery <a href="#RFC7050">[RFC7050]</a> to discover the IPv6 prefix used by NAT64 (if any) and generate server reflexive candidates for each IPv6-only interface accordingly.  The NAT64 server reflexive candidates are prioritized like IPv4 server reflexive candidates.  </p>
<h1 id="rfc.section.4.1.1.3"><a href="#rfc.section.4.1.1.3">4.1.1.3.</a> <a href="#sec-computing-foundations" id="sec-computing-foundations">Computing Foundations</a></h1>
<p id="rfc.section.4.1.1.3.p.1">Finally, the agent assigns each candidate a foundation. The foundation is an identifier, scoped within a session. Two candidates MUST have the same foundation ID when all of the following are true: </p>
<p/>

<ul>
  <li>they are of the same type (host, relayed, server reflexive, or peer reflexive)</li>
  <li>their bases have the same IP address (the ports can be different)</li>
  <li>for reflexive and relayed candidates, the STUN or TURN servers used to obtain them have the same IP address </li>
  <li>they were obtained using the same transport protocol (TCP, UDP, etc.) </li>
</ul>
<p id="rfc.section.4.1.1.3.p.3">Similarly, two candidates MUST have different foundations if their types are different, their bases have different IP addresses, the STUN or TURN servers used to obtain them have different IP addresses, or their transport protocols are different.  </p>
<h1 id="rfc.section.4.1.1.4"><a href="#rfc.section.4.1.1.4">4.1.1.4.</a> Keeping Candidates Alive</h1>
<p id="rfc.section.4.1.1.4.p.1">Once server reflexive and relayed candidates are allocated, they MUST be kept alive until ICE processing has completed, as described in <a href="#sec-freeing">Section 7.3</a>. For server reflexive candidates learned through a Binding request, the bindings MUST be kept alive by additional Binding requests to the server. Refreshes for allocations are done using the Refresh transaction, as described in <a href="#RFC5766">[RFC5766]</a>. The Refresh requests will also refresh the server reflexive candidate.  </p>
<h1 id="rfc.section.4.1.2"><a href="#rfc.section.4.1.2">4.1.2.</a> <a href="#sec-prioritizing" id="sec-prioritizing">Prioritizing Candidates</a></h1>
<p id="rfc.section.4.1.2.p.1">The prioritization process results in the assignment of a priority to each candidate. Each candidate for a media stream MUST have a unique priority that MUST be a positive integer between 1 and (2**31 - 1).  This priority will be used by ICE to determine the order of the connectivity checks and the relative preference for candidates.  </p>
<p id="rfc.section.4.1.2.p.2">An agent SHOULD compute this priority using the formula in <a href="#sec-rec-form">Section 4.1.2.1</a> and choose its parameters using the guidelines in <a href="#sec-guidelines">Section 4.1.2.2</a>.  If an agent elects to use a different formula, ICE will take longer to converge since both agents will not be coordinated in their checks.  </p>
<p id="rfc.section.4.1.2.p.3">The process for prioritizing candidates is common across the initiating and the responding agent.  </p>
<h1 id="rfc.section.4.1.2.1"><a href="#rfc.section.4.1.2.1">4.1.2.1.</a> <a href="#sec-rec-form" id="sec-rec-form">Recommended Formula</a></h1>
<p id="rfc.section.4.1.2.1.p.1">When using the formula, an agent computes the priority by determining a preference for each type of candidate (server reflexive, peer reflexive, relayed, and host), and, when the agent is multihomed, choosing a preference for its IP addresses. These two preferences are then combined to compute the priority for a candidate. That priority is computed using the following formula: </p>
<pre>

priority = (2^24)*(type preference) +
           (2^8)*(local preference) +
           (2^0)*(256 - component ID)

</pre>
<p id="rfc.section.4.1.2.1.p.2">The type preference MUST be an integer from 0 to 126 inclusive, and represents the preference for the type of the candidate (where the types are local, server reflexive, peer reflexive, and relayed). A 126 is the highest preference, and a 0 is the lowest. Setting the value to a 0 means that candidates of this type will only be used as a last resort. The type preference MUST be identical for all candidates of the same type and MUST be different for candidates of different types. The type preference for peer reflexive candidates MUST be higher than that of server reflexive candidates. Note that candidates gathered based on the procedures of <a href="#sec-gathering">Section 4.1.1</a> will never be peer reflexive candidates; candidates of these type are learned from the connectivity checks performed by ICE.  </p>
<p id="rfc.section.4.1.2.1.p.3">The local preference MUST be an integer from 0 to 65535 inclusive. It represents a preference for the particular IP address from which the candidate was obtained. 65535 represents the highest preference, and a zero, the lowest. When there is only a single IP address, this value SHOULD be set to 65535. More generally, if there are multiple candidates for a particular component for a particular media stream that have the same type, the local preference MUST be unique for each one. In this specification, this only happens for multihomed hosts or if an agent is using multiple TURN servers. If a host is multihomed because it is dual-stack, the local preference SHOULD be set equal to the precedence value for IP addresses described in RFC 6724 <a href="#RFC6724">[RFC6724]</a>. If the host operating system provides an API for discovering preference among different addresses, those preferences SHOULD be used for the local preference to prioritize addresses indicated as preferred by the operating system.  </p>
<p id="rfc.section.4.1.2.1.p.4">The component ID is the component ID for the candidate, and MUST be between 1 and 256 inclusive.  </p>
<h1 id="rfc.section.4.1.2.2"><a href="#rfc.section.4.1.2.2">4.1.2.2.</a> <a href="#sec-guidelines" id="sec-guidelines">Guidelines for Choosing Type and Local Preferences</a></h1>
<p id="rfc.section.4.1.2.2.p.1">One criterion for selection of the type and local preference values is the use of a media intermediary, such as a TURN server, VPN server, or NAT. With a media intermediary, if media is sent to that candidate, it will first transit the media intermediary before being received. Relayed candidates are one type of candidate that involves a media intermediary. Another are host candidates obtained from a VPN interface. When media is transited through a media intermediary, it can increase the latency between transmission and reception. It can increase the packet losses, because of the additional router hops that may be taken. It may increase the cost of providing service, since media will be routed in and right back out of a media intermediary run by a provider. If these concerns are important, the type preference for relayed candidates SHOULD be lower than host candidates. The RECOMMENDED values are 126 for host candidates, 100 for server reflexive candidates, 110 for peer reflexive candidates, and 0 for relayed candidates.</p>
<p id="rfc.section.4.1.2.2.p.2">Furthermore, if an agent is multihomed and has multiple IP addresses, the local preference for host candidates from a VPN interface SHOULD have a priority of 0. If multiple TURN servers are used, local priorities for the candidates obtained from the TURN servers are chosen in a similar fashion as for multihomed local candidates: the local preference value is used to indicate preference among different servers but the preference MUST be unique for each one. </p>
<p id="rfc.section.4.1.2.2.p.3">Another criterion for selection of preferences is IP address family. ICE works with both IPv4 and IPv6. It therefore provides a transition mechanism that allows dual-stack hosts to prefer connectivity over IPv6, but to fall back to IPv4 in case the v6 networks are disconnected (due, for example, to a failure in a 6to4 relay) <a href="#RFC3056">[RFC3056]</a>. It can also help with hosts that have both a native IPv6 address and a 6to4 address. In such a case, higher local preferences could be assigned to the v6 addresses, followed by the 6to4 addresses, followed by the v4 addresses. This allows a site to obtain and begin using native v6 addresses immediately, yet still fall back to 6to4 addresses when communicating with agents in other sites that do not yet have native v6 connectivity.  </p>
<p id="rfc.section.4.1.2.2.p.4">Another criterion for selecting preferences is security. If a user is a telecommuter, and therefore connected to a corporate network and a local home network, the user may prefer their voice traffic to be routed over the VPN in order to keep it on the corporate network when communicating within the enterprise, but use the local network when communicating with users outside of the enterprise. In such a case, a VPN address would have a higher local preference than any other address.  </p>
<p id="rfc.section.4.1.2.2.p.5">Another criterion for selecting preferences is topological awareness. This is most useful for candidates that make use of intermediaries. In those cases, if an agent has preconfigured or dynamically discovered knowledge of the topological proximity of the intermediaries to itself, it can use that to assign higher local preferences to candidates obtained from closer intermediaries.  </p>
<h1 id="rfc.section.4.1.3"><a href="#rfc.section.4.1.3">4.1.3.</a> <a href="#sec-el-red" id="sec-el-red">Eliminating Redundant Candidates</a></h1>
<p id="rfc.section.4.1.3.p.1">Next, the agent eliminates redundant candidates. A candidate is redundant if its transport address equals another candidate, and its base equals the base of that other candidate. Note that two candidates can have the same transport address yet have different bases, and these would not be considered redundant. Frequently, a server reflexive candidate and a host candidate will be redundant when the agent is not behind a NAT. The agent SHOULD eliminate the redundant candidate with the lower priority.  </p>
<p id="rfc.section.4.1.3.p.2">This process is common across the initiating and responding agents.  </p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#sec-offer-lite" id="sec-offer-lite">Lite Implementation Procedures</a></h1>
<p id="rfc.section.4.2.p.1">Lite implementations only utilize host candidates. A lite implementation MUST, for each component of each media stream, allocate zero or one IPv4 candidates. It MAY allocate zero or more IPv6 candidates, but no more than one per each IPv6 address utilized by the host. Since there can be no more than one IPv4 candidate per component of each media stream, if an agent has multiple IPv4 addresses, it MUST choose one for allocating the candidate. If a host is dual-stack, it is RECOMMENDED that it allocate one IPv4 candidate and one global IPv6 address. With the lite implementation, ICE cannot be used to dynamically choose amongst candidates. Therefore, including more than one candidate from a particular scope is NOT RECOMMENDED, since only a connectivity check can truly determine whether to use one address or the other.  </p>
<p id="rfc.section.4.2.p.2">Each component has an ID assigned to it, called the component ID.  For RTP-based media streams, unless RTCP is multiplexed in the same port with RTP, the RTP itself has a component ID of 1, and RTCP a component ID of 2. If an agent is using RTCP without multiplexing, it MUST obtain candidates for it.  However, absence of a component ID 2 as such does not imply use of RTCP/RTP multiplexing, as it could also mean that RTCP is not used.</p>
<p id="rfc.section.4.2.p.3">Each candidate is assigned a foundation. The foundation MUST be different for two candidates allocated from different IP addresses, and MUST be the same otherwise. A simple integer that increments for each IP address will suffice. In addition, each candidate MUST be assigned a unique priority amongst all candidates for the same media stream. This priority SHOULD be equal to: </p>
<pre>

priority = (2^24)*(126) +
           (2^8)*(IP precedence) +
           (2^0)*(256 - component ID)

</pre>
<p id="rfc.section.4.2.p.4">If a host is v4-only, it SHOULD set the IP precedence to 65535. If a host is v6 or dual-stack, the IP precedence SHOULD be the precedence value for IP addresses described in RFC 6724 <a href="#RFC6724">[RFC6724]</a>.  </p>
<p id="rfc.section.4.2.p.5">Next, an agent chooses a default candidate for each component of each media stream. If a host is IPv4-only, there would only be one candidate for each component of each media stream, and therefore that candidate is the default. If a host is IPv6 or dual-stack, the selection of default is a matter of local policy. This default SHOULD be chosen such that it is the candidate most likely to be used with a peer. For IPv6-only hosts, this would typically be a globally scoped IPv6 address. For dual-stack hosts, the IPv4 address is RECOMMENDED.  </p>
<p id="rfc.section.4.2.p.6">The procedures in this section is common across the initiating and responding agents.  </p>
<h1 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#sec-encoding" id="sec-encoding">Encoding the Candidate Information</a></h1>
<p id="rfc.section.4.3.p.1">Regardless of the agent being an Initiator or Responder Agent, the following parameters and their data types needs to be conveyed as part of the candidate exchange process. The specifics of syntax for encoding the candidate information is out of scope of this specification.  </p>
<p/>

<dl>
  <dt>Candidate attribute</dt>
  <dd style="margin-left: 8">There will be one or more of these for each "media stream". Each candidate is composed of: <dl><dt>Connection Address:</dt><dd style="margin-left: 8">The IP address and transport protocol port of the candidate. </dd><dt>Transport:</dt><dd style="margin-left: 8">An indicator of the transport protocol for this candidate. This need not be present if the using protocol will only ever run over a single transport protocol. If it runs over more than one, or if others are anticipated to be used in the future, this should be present. </dd><dt>Foundation:</dt><dd style="margin-left: 8">A sequence of up to 32 characters.</dd><dt>Component-ID:</dt><dd style="margin-left: 8">This would be present only if the using protocol were utilizing the concept of components. If it is, it would be a positive integer that indicates the component ID for which this is a candidate. </dd><dt>Priority:</dt><dd style="margin-left: 8">An encoding of the 32-bit priority value. </dd><dt>Candidate Type:</dt><dd style="margin-left: 8">The candidate type, as defined in ICE. </dd><dt>Related Address and Port:</dt><dd style="margin-left: 8">The related IP address and port for this candidate, as defined by ICE. These MAY be omitted or set to invalid values if the agent does not want to reveal them, e.g., for privacy reasons.  </dd><dt>Extensibility Parameters:</dt><dd style="margin-left: 8">The using protocol should define some means for adding new per-candidate ICE parameters in the future. </dd></dl></dd>
  <dt>Lite Flag:</dt>
  <dd style="margin-left: 8">If ICE lite is used by the using protocol, it needs to convey a boolean parameter which indicates whether the implementation is lite or not. </dd>
  <dt>Connectivity check pacing value:</dt>
  <dd style="margin-left: 8">If an agent wants to use other than the default pacing values for the connectivity checks, it MUST indicate this in the ICE exchange. </dd>
  <dt>Username Fragment and Password:</dt>
  <dd style="margin-left: 8">The using protocol has to convey a username fragment and password. The username fragment MUST contain at least 24 bits of randomness, and the password MUST contain at least 128 bits of randomness. </dd>
  <dt>ICE extensions:</dt>
  <dd style="margin-left: 8">In addition to the per-candidate extensions above, the using protocol should allow for new media-stream or session-level attributes (ice-options).  </dd>
</dl>
<p id="rfc.section.4.3.p.3">If the using protocol is using the ICE mismatch feature, a way is needed to convey this parameter in answers. It is a boolean flag.  </p>
<p id="rfc.section.4.3.p.4">The exchange of parameters is symmetric; both agents need to send the same set of attributes as defined above.  </p>
<p id="rfc.section.4.3.p.5">The using protocol may (or may not) need to deal with backwards compatibility with older implementations that do not support ICE. If the fallback mechanism is being used, then presumably the using protocol provides a way of conveying the default candidate (its IP address and port) in addition to the ICE parameters.  </p>
<p id="rfc.section.4.3.p.6">STUN connectivity checks between agents are authenticated using the short-term credential mechanism defined for STUN [RFC5389].  This mechanism relies on a username and password that are exchanged through protocol machinery between the client and server. The username part of this credential is formed by concatenating a username fragment from each agent, separated by a colon.  Each agent also provides a password, used to compute the message integrity for requests it receives.  The username fragment and password are exchanged between the peers.  In addition to providing security, the username provides disambiguation and correlation of checks to media streams.  See Appendix B.4 for motivation.  </p>
<p id="rfc.section.4.3.p.7">If the initiating agent is a lite implementation, it MUST indicate this when sending its candidates .  </p>
<p id="rfc.section.4.3.p.8">ICE provides for extensibility by allowing an agent to include a series of tokens that identify ICE extensions as part of the candidate exchange process.  </p>
<p id="rfc.section.4.3.p.9">Once an agent has sent its candidate information, that agent MUST be prepared to receive both STUN and media packets on each candidate. As discussed in <a href="#sec-send-media">Section 10.1</a>, media packets can be sent to a candidate prior to its appearance as the default destination for media.  </p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#sec-candidate_proc" id="sec-candidate_proc">ICE Candidate Processing</a></h1>
<p id="rfc.section.5.p.1">Once an agent has candidates from it's peer, it will check if the peer supports ICE, determine its own role, exchanges candidates (<a href="#sec-gathering_exchange">Section 4</a>) and for full implementations, forms the check lists and begins connectivity checks as explained in this section.  </p>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#sec-candidate_proc_full" id="sec-candidate_proc_full">Procedures for Full Implementation</a></h1>
<h1 id="rfc.section.5.1.1"><a href="#rfc.section.5.1.1">5.1.1.</a> <a href="#sec-verify" id="sec-verify">Verifying ICE Support</a></h1>
<p id="rfc.section.5.1.1.p.1">Certain middleboxes, such as ALGs, may alter the ICE candidate information that breaks ICE. If the using protocol is vulnerable to this kind of changes, called ICE mismatch, the responding agent needs to detect this and signal this back to the initiating agent. The details on whether this is needed and how it is done is defined by the usage specifications. One exception to the above is that an initiating agent would never indicate ICE mismatch.  </p>
<h1 id="rfc.section.5.1.2"><a href="#rfc.section.5.1.2">5.1.2.</a> <a href="#sec-role" id="sec-role">Determining Role</a></h1>
<p id="rfc.section.5.1.2.p.1">For each session, each agent (Initiating and Responding) takes on a role.  There are two roles -- controlling and controlled. The controlling agent is responsible for the choice of the final candidate pairs used for communications. For a full agent, this means nominating the candidate pairs that can be used by ICE for each media stream, and for updating the peer with the ICE's selection, when needed. The controlled agent is told which candidate pairs to use for each media stream, and does not require updating the peer to signal this information. The sections below describe in detail the actual procedures followed by controlling and controlled nodes.  </p>
<p id="rfc.section.5.1.2.p.2">The rules for determining the role and the impact on behavior are as follows: </p>
<p/>

<dl>
  <dt>Both agents are full:</dt>
  <dd style="margin-left: 8">The Initiating Agent which started the ICE processing MUST take the controlling role, and the other MUST take the controlled role. Both agents will form check lists, run the ICE state machines, and generate connectivity checks. The controlling agent will execute the logic in <a href="#sec-conclude-full">Section 7.1</a> to nominate pairs that will be selected by ICE, and then both agents end ICE as described in <a href="#sec-conc-state">Section 7.1.2</a>.  </dd>
  <dt>One agent full, one lite:</dt>
  <dd style="margin-left: 8">The full agent MUST take the controlling role, and the lite agent MUST take the controlled role. The full agent will form check lists, run the ICE state machines, and generate connectivity checks. That agent will execute the logic in <a href="#sec-conclude-full">Section 7.1</a> to nominate pairs that will be selected by ICE, and use the logic in <a href="#sec-conc-state">Section 7.1.2</a> to end ICE. The lite implementation will just listen for connectivity checks, receive them and respond to them, and then conclude ICE as described in <a href="#sec-lite-conclude">Section 7.2</a>. For the lite implementation, the state of ICE processing for each media stream is considered to be Running, and the state of ICE overall is Running.  </dd>
  <dt>Both lite:</dt>
  <dd style="margin-left: 8">The Initiating Agent which started the ICE processing MUST take the controlling role, and the other MUST take the controlled role. In this case, no connectivity checks are ever sent. Rather, once the candidates are exchanged, each agent performs the processing described in <a href="#sec-conclude">Section 7</a> without connectivity checks. It is possible that both agents will believe they are controlled or controlling. In the latter case, the conflict is resolved through glare detection capabilities in the signaling protocol enabling the candidate exchange. The state of ICE processing for each media stream is considered to be Running, and the state of ICE overall is Running.  </dd>
</dl>
<p id="rfc.section.5.1.2.p.4">Once roles are determined for a session, they persist unless ICE is restarted. An ICE restart causes a new selection of roles and tie-breakers.  </p>
<h1 id="rfc.section.5.1.3"><a href="#rfc.section.5.1.3">5.1.3.</a> <a href="#sec-forming" id="sec-forming">Forming the Check Lists</a></h1>
<p id="rfc.section.5.1.3.p.1">There is one check list per in-use media stream resulting from the candidate exchange.  To form the check list for a media stream, the agent forms candidate pairs, computes a candidate pair priority, orders the pairs by priority, prunes them, and sets their states. These steps are described in this section.  </p>
<h1 id="rfc.section.5.1.3.1"><a href="#rfc.section.5.1.3.1">5.1.3.1.</a> Forming Candidate Pairs</h1>
<p id="rfc.section.5.1.3.1.p.1">First, the agent takes each of its candidates for a media stream (called LOCAL CANDIDATES) and pairs them with the candidates it received from its peer (called REMOTE CANDIDATES) for that media stream. In order to prevent the attacks described in <a href="#sec-ice-hammer">Section 14.4.1</a>, agents MAY limit the number of candidates they'll accept in an candidate exchange process. A local candidate is paired with a remote candidate if and only if the two candidates have the same component ID and have the same IP address version. It is possible that some of the local candidates won't get paired with remote candidates, and some of the remote candidates won't get paired with local candidates. This can happen if one agent doesn't include candidates for the all of the components for a media stream. If this happens, the number of components for that media stream is effectively reduced, and considered to be equal to the minimum across both agents of the maximum component ID provided by each agent across all components for the media stream.  </p>
<p id="rfc.section.5.1.3.1.p.2">In the case of RTP, this would happen when one agent provides candidates for RTCP, and the other does not. As another example, the initiating agent can multiplex RTP and RTCP on the same port <a href="#RFC5761">[RFC5761]</a>. However, since the initiating agent doesn't know if the peer agent can perform such multiplexing, it includes candidates for RTP and RTCP on separate ports. If the peer agent can perform such multiplexing, it would include just a single component for each candidate -- for the combined RTP/RTCP mux. ICE would end up acting as if there was just a single component for this candidate.  </p>
<p id="rfc.section.5.1.3.1.p.3">With IPv6 it is common for a host to have multiple host candidates for each interface. To keep the amount of resulting candidate pairs reasonable and to avoid candidate pairs that are highly unlikely to work, IPv6 link-local addresses <a href="#RFC4291">[RFC4291]</a> MUST NOT be paired with other than link-local addresses. </p>
<p id="rfc.section.5.1.3.1.p.4">The candidate pairs whose local and remote candidates are both the default candidates for a particular component is called, unsurprisingly, the default candidate pair for that component. This is the pair that would be used to transmit media if both agents had not been ICE aware.  </p>
<p id="rfc.section.5.1.3.1.p.5">In order to aid understanding, <a href="#fig-check-model">Figure 7</a> shows the relationships between several key concepts -- transport addresses, candidates, candidate pairs, and check lists, in addition to indicating the main properties of candidates and candidate pairs.  </p>
<div id="rfc.figure.7"/>
<div id="fig-check-model"/>
<pre>

    +--------------------------------------------+
    |                                            |
    | +---------------------+                    |
    | |+----+ +----+ +----+ |   +Type            |
    | || IP | |Port| |Tran| |   +Priority        |
    | ||Addr| |    | |    | |   +Foundation      |
    | |+----+ +----+ +----+ |   +Component ID    |
    | |      Transport      |   +Related Address |
    | |        Addr         |                    |
    | +---------------------+   +Base            |
    |             Candidate                      |
    +--------------------------------------------+
    *                                         *
    *    *************************************
    *    *
  +-------------------------------+
 .|                               |
  | Local     Remote              |
  | +----+    +----+   +default?  |
  | |Cand|    |Cand|   +valid?    |
  | +----+    +----+   +nominated?|
  |                    +State     |
  |                               |
  |                               |
  |          Candidate Pair       |
  +-------------------------------+
  *                              *
  *                  ************
  *                  *
  +------------------+
  |  Candidate Pair  |
  +------------------+
  +------------------+
  |  Candidate Pair  |
  +------------------+
  +------------------+
  |  Candidate Pair  |
  +------------------+


         Check
         List

</pre>
<p class="figure">Figure 7: Conceptual Diagram of a Check List</p>
<h1 id="rfc.section.5.1.3.2"><a href="#rfc.section.5.1.3.2">5.1.3.2.</a> <a href="#sec-comp-pair-prio" id="sec-comp-pair-prio">Computing Pair Priority and Ordering Pairs</a></h1>
<p id="rfc.section.5.1.3.2.p.1">Once the pairs are formed, a candidate pair priority is computed. Let G be the priority for the candidate provided by the controlling agent. Let D be the priority for the candidate provided by the controlled agent. The priority for a pair is computed as: </p>
<p/>

<ul class="empty">
  <li>pair priority = 2^32*MIN(G,D) + 2*MAX(G,D) + (G&gt;D?1:0) </li>
</ul>
<p id="rfc.section.5.1.3.2.p.3">Where G&gt;D?1:0 is an expression whose value is 1 if G is greater than D, and 0 otherwise. Once the priority is assigned, the agent sorts the candidate pairs in decreasing order of priority. If two pairs have identical priority, the ordering amongst them is arbitrary.  </p>
<h1 id="rfc.section.5.1.3.3"><a href="#rfc.section.5.1.3.3">5.1.3.3.</a> Pruning the Pairs</h1>
<p id="rfc.section.5.1.3.3.p.1">This sorted list of candidate pairs is used to determine a sequence of connectivity checks that will be performed. Each check involves sending a request from a local candidate to a remote candidate. Since an agent cannot send requests directly from a reflexive candidate, but only from its base, the agent next goes through the sorted list of candidate pairs. For each pair where the local candidate is server reflexive, the server reflexive candidate MUST be replaced by its base. Once this has been done, the agent MUST prune the list. This is done by removing a pair if its local and remote candidates are identical to the local and remote candidates of a pair higher up on the priority list. The result is a sequence of ordered candidate pairs, called the check list for that media stream.  </p>
<p id="rfc.section.5.1.3.3.p.2">In addition, in order to limit the attacks described in <a href="#sec-ice-hammer">Section 14.4.1</a>, an agent MUST limit the total number of connectivity checks the agent performs across all check lists to a specific value, and this value MUST be configurable. A default of 100 is RECOMMENDED. This limit is enforced by discarding the lower-priority candidate pairs until there are less than 100. It is RECOMMENDED that a lower value be utilized when possible, set to the maximum number of plausible checks that might be seen in an actual deployment configuration. The requirement for configuration is meant to provide a tool for fixing this value in the field if, once deployed, it is found to be problematic.  </p>
<h1 id="rfc.section.5.1.3.4"><a href="#rfc.section.5.1.3.4">5.1.3.4.</a> Computing States</h1>
<p id="rfc.section.5.1.3.4.p.1">Each candidate pair in the check list has a foundation and a state.  The foundation is the combination of the foundations of the local and remote candidates in the pair. The state is assigned once the check list for each media stream has been computed. There are five potential values that the state can have: </p>
<p/>

<dl>
  <dt>Waiting:</dt>
  <dd style="margin-left: 8">A check has not been performed for this pair, and can be performed as soon as it is the highest-priority Waiting pair on the check list.  </dd>
  <dt>In-Progress:</dt>
  <dd style="margin-left: 8">A check has been sent for this pair, but the transaction is in progress.  </dd>
  <dt>Succeeded:</dt>
  <dd style="margin-left: 8">A check for this pair was already done and produced a successful result.  </dd>
  <dt>Failed:</dt>
  <dd style="margin-left: 8">A check for this pair was already done and failed, either never producing any response or producing an unrecoverable failure response.  </dd>
  <dt>Frozen:</dt>
  <dd style="margin-left: 8">A check for this pair hasn't been performed, and it can't yet be performed until some other check succeeds, allowing this pair to unfreeze and move into the Waiting state.  </dd>
</dl>
<p id="rfc.section.5.1.3.4.p.3">As ICE runs, the pairs will move between states as shown in <a href="#fig-state-fsm">Figure 8</a>.  </p>
<div id="rfc.figure.8"/>
<div id="fig-state-fsm"/>
<pre>

   +-----------+
   |           |
   |           |
   |  Frozen   |
   |           |
   |           |
   +-----------+
         |
         |unfreeze
         |
         V
   +-----------+         +-----------+
   |           |         |           |
   |           | perform |           |
   |  Waiting  |--------&gt;|In-Progress|
   |           |         |           |
   |           |         |           |
   +-----------+         +-----------+
                               / |
                             //  |
                           //    |
                         //      |
                        /        |
                      //         |
            failure //           |success
                  //             |
                 /               |
               //                |
             //                  |
           //                    |
          V                      V
   +-----------+         +-----------+
   |           |         |           |
   |           |         |           |
   |   Failed  |         | Succeeded |
   |           |         |           |
   |           |         |           |
   +-----------+         +-----------+
</pre>
<p class="figure">Figure 8: Pair State FSM</p>
<p id="rfc.section.5.1.3.4.p.4">The initial states for each pair in a check list are computed by performing the following sequence of steps: </p>
<p/>

<ol>
  <li>The agent sets all of the pairs in each check list to the Frozen state.  </li>
  <li>The agent examines the check list for the first media stream. For that media stream: <ul><li>For all pairs with the same foundation, it sets the state of the pair with the lowest component ID to Waiting. If there is more than one such pair, the one with the highest-priority is used.  </li></ul></li>
</ol>
<p id="rfc.section.5.1.3.4.p.6">One of the check lists will have some number of pairs in the Waiting state, and the other check lists will have all of their pairs in the Frozen state. A check list with at least one pair that is Waiting is called an active check list, and a check list with all pairs Frozen is called a frozen check list.  </p>
<p id="rfc.section.5.1.3.4.p.7">The check list itself is associated with a state, which captures the state of ICE checks for that media stream. There are three states:</p>
<p/>

<dl>
  <dt>Running:</dt>
  <dd style="margin-left: 8">In this state, ICE checks are still in progress for this media stream.  </dd>
  <dt>Completed:</dt>
  <dd style="margin-left: 8">In this state, ICE checks have produced nominated pairs for each component of the media stream. Consequently, ICE has succeeded and media can be sent.  </dd>
  <dt>Failed:</dt>
  <dd style="margin-left: 8">In this state, the ICE checks have not completed successfully for this media stream.  </dd>
</dl>
<p id="rfc.section.5.1.3.4.p.9">When a check list is first constructed as the consequence of an candidate exchange, it is placed in the Running state.  </p>
<p id="rfc.section.5.1.3.4.p.10">ICE processing across all media streams also has a state associated with it. This state is equal to Running while ICE processing is under way. The state is Completed when ICE processing is complete and Failed if it failed without success.  Rules for transitioning between states are described below.  </p>
<h1 id="rfc.section.5.1.4"><a href="#rfc.section.5.1.4">5.1.4.</a> <a href="#sec-periodic" id="sec-periodic">Scheduling Checks</a></h1>
<p id="rfc.section.5.1.4.p.1">An agent performs ordinary checks and triggered checks. The generation of both checks is governed by a timer that fires periodically for each media stream. The agent maintains a FIFO queue, called the triggered check queue, which contains candidate pairs for which checks are to be sent at the next available opportunity. When the timer fires, the agent removes the top pair from the triggered check queue, performs a connectivity check on that pair, and sets the state of the candidate pair to In-Progress. If there are no pairs in the triggered check queue, an ordinary check is sent.  </p>
<p id="rfc.section.5.1.4.p.2">Once the agent has computed the check lists as described in <a href="#sec-forming">Section 5.1.3</a>, it sets a timer for each active check list. The timer fires every Ta*N seconds, where N is the number of active check lists (initially, there is only one active check list). Implementations MAY set the timer to fire less frequently than this. Implementations SHOULD take care to spread out these timers so that they do not fire at the same time for each media stream. Ta and the retransmit timer RTO are computed as described in <a href="#sec-ta">Section 12</a>. Multiplying by N allows this aggregate check throughput to be split between all active check lists. The first timer fires immediately, so that the agent performs a connectivity check the moment the candidate exchange has been done, followed by the next check Ta seconds later (since there is only one active check list).  </p>
<p id="rfc.section.5.1.4.p.3">When the timer fires and there is no triggered check to be sent, the agent MUST choose an ordinary check as follows: </p>

<ul>
  <li>Find the highest-priority pair in that check list that is in the Waiting state.  </li>
  <li>If there is such a pair: <ul><li>Send a STUN check from the local candidate of that pair to the remote candidate of that pair. The procedures for forming the STUN request for this purpose are described in <a href="#sec-send-check">Section 6.1.2</a>.  </li><li>Set the state of the candidate pair to In-Progress.  </li></ul></li>
  <li>If there is no such pair: <ul><li>Find the highest-priority pair in that check list that is in the Frozen state.  </li><li>If there is such a pair: <ul><li>Unfreeze the pair.</li><li>Perform a check for that pair, causing its state to transition to In-Progress.  </li></ul></li><li>If there is no such pair: <ul><li>Terminate the timer for that check list.</li></ul></li></ul></li>
</ul>
<p id="rfc.section.5.1.4.p.4">To compute the message integrity for the check, the agent uses the remote username fragment and password learned from the candidate information obtained from its peer. The local username fragment is known directly by the agent for its own candidate.  </p>
<p id="rfc.section.5.1.4.p.5">The Initiator performs the ordinary checks on receiving the candidate information from the Peer (responder) and having formed the checklists.  On the  other hand the responding agent either performs the triggered or ordinary checks as described above.  </p>
<h1 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#sec-candidate_proc_lite" id="sec-candidate_proc_lite">Lite Implementation Procedures</a></h1>
<p id="rfc.section.5.2.p.1">Lite implementations skips most of the steps in <a href="#sec-candidate_proc">Section 5</a> except for verifying the peer's ICE support and determining its role in the ICE processing.  </p>
<p id="rfc.section.5.2.p.2">On determining the role for a lite implementation being the controlling agent means selecting a candidate pair based on the ones in the candidate exchange (for IPv4, there is only ever one pair), and then updating the peer with the new candidate information reflecting that selection, when needed (it is never needed for an IPv4-only host). The controlled agent is told which candidate pairs to use for each media stream, and no further candidate updates are needed to signal this information.  </p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#sec-connectivity_check" id="sec-connectivity_check">Performing Connectivity Checks</a></h1>
<p id="rfc.section.6.p.1">This section describes how connectivity checks are performed. All ICE implementations are required to be compliant to <a href="#RFC5389">[RFC5389]</a>, as opposed to the older <a href="#RFC3489">[RFC3489]</a>. However, whereas a full implementation will both generate checks (acting as a STUN client) and receive them (acting as a STUN server), a lite implementation will only receive checks, and thus will only act as a STUN server.  </p>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#sec-client" id="sec-client">STUN Client Procedures</a></h1>
<p id="rfc.section.6.1.p.1">These procedures define how an agent sends a connectivity check, whether it is an ordinary or a triggered check. These procedures are only applicable to full implementations.  </p>
<h1 id="rfc.section.6.1.1"><a href="#rfc.section.6.1.1">6.1.1.</a> <a href="#sec-permissions" id="sec-permissions">Creating Permissions for Relayed Candidates</a></h1>
<p id="rfc.section.6.1.1.p.1">If the connectivity check is being sent using a relayed local candidate, the client MUST create a permission first if it has not already created one previously.  It would have created one previously if it had told the TURN server to create a permission for the given relayed candidate towards the IP address of the remote candidate.  To create the permission, the agent follows the procedures defined in <a href="#RFC5766">[RFC5766]</a>.  The permission MUST be created towards the IP address of the remote candidate.  It is RECOMMENDED that the agent defer creation of a TURN channel until ICE completes, in which case permissions for connectivity checks are normally created using a CreatePermission request.  Once established, the agent MUST keep the permission active until ICE concludes.  </p>
<h1 id="rfc.section.6.1.2"><a href="#rfc.section.6.1.2">6.1.2.</a> <a href="#sec-send-check" id="sec-send-check">Sending the Request</a></h1>
<p id="rfc.section.6.1.2.p.1">A connectivity check is generated by sending a Binding request from a local candidate to a remote candidate. <a href="#RFC5389">[RFC5389]</a> describes how Binding requests are constructed and generated. A connectivity check MUST utilize the STUN short-term credential mechanism. Support for backwards compatibility with RFC 3489 MUST NOT be used or assumed with connectivity checks. The FINGERPRINT mechanism MUST be used for connectivity checks.  </p>
<p id="rfc.section.6.1.2.p.2">ICE extends STUN by defining several new attributes, including PRIORITY, USE-CANDIDATE, ICE-CONTROLLED, and ICE-CONTROLLING. These new attributes are formally defined in <a href="#sec-ice-newatts">Section 15.1</a>, and their usage is described in the subsections below. These STUN extensions are applicable only to connectivity checks used for ICE.  </p>
<h1 id="rfc.section.6.1.2.1"><a href="#rfc.section.6.1.2.1">6.1.2.1.</a> PRIORITY and USE-CANDIDATE</h1>
<p id="rfc.section.6.1.2.1.p.1">An agent MUST include the PRIORITY attribute in its Binding request. The attribute MUST be set equal to the priority that would be assigned, based on the algorithm in <a href="#sec-prioritizing">Section 4.1.2</a>, to a peer reflexive candidate, should one be learned as a consequence of this check (see <a href="#sec-learn-peer-client">Section 6.1.3.2.1</a> for how peer reflexive candidates are learned). This priority value will be computed identically to how the priority for the local candidate of the pair was computed, except that the type preference is set to the value for peer reflexive candidate types.  </p>
<p id="rfc.section.6.1.2.1.p.2">The controlling agent MAY include the USE-CANDIDATE attribute in the Binding request. The controlled agent MUST NOT include it in its Binding request. This attribute signals that the controlling agent wishes to cease checks for this component, and use the candidate pair resulting from the check for this component. <a href="#sec-choose-favor">Section 7.1.1</a> provides guidance on determining when to include it.  </p>
<h1 id="rfc.section.6.1.2.2"><a href="#rfc.section.6.1.2.2">6.1.2.2.</a> <a href="#sec-tie-client" id="sec-tie-client">ICE-CONTROLLED and ICE-CONTROLLING</a></h1>
<p id="rfc.section.6.1.2.2.p.1">The agent MUST include the ICE-CONTROLLED attribute in the request if it is in the controlled role, and MUST include the ICE-CONTROLLING attribute in the request if it is in the controlling role. The content of either attribute MUST be the tie-breaker that was determined in <a href="#sec-role">Section 5.1.2</a>. These attributes are defined fully in <a href="#sec-ice-newatts">Section 15.1</a>.  </p>
<h1 id="rfc.section.6.1.2.3"><a href="#rfc.section.6.1.2.3">6.1.2.3.</a> Forming Credentials</h1>
<p id="rfc.section.6.1.2.3.p.1">A Binding request serving as a connectivity check MUST utilize the STUN short-term credential mechanism. The username for the credential is formed by concatenating the username fragment provided by the peer with the username fragment of the agent sending the request, separated by a colon (":"). The password is equal to the password provided by the peer. For example, consider the case where agent L is the initiating , agent and agent R is the responding agent. Agent L included a username fragment of LFRAG for its candidates and a password of LPASS. Agent R provided a username fragment of RFRAG and a password of RPASS. A connectivity check from L to R utilizes the username RFRAG:LFRAG and a password of RPASS. A connectivity check from R to L utilizes the username LFRAG:RFRAG and a password of LPASS. The responses utilize the same usernames and passwords as the requests (note that the USERNAME attribute is not present in the response).  </p>
<h1 id="rfc.section.6.1.2.4"><a href="#rfc.section.6.1.2.4">6.1.2.4.</a> DiffServ Treatment</h1>
<p id="rfc.section.6.1.2.4.p.1">If the agent is using Diffserv Codepoint markings <a href="#RFC2475">[RFC2475]</a> in its media packets, it SHOULD apply those same markings to its connectivity checks.  </p>
<h1 id="rfc.section.6.1.3"><a href="#rfc.section.6.1.3">6.1.3.</a> <a href="#sec-recv-response" id="sec-recv-response">Processing the Response</a></h1>
<p id="rfc.section.6.1.3.p.1">When a Binding response is received, it is correlated to its Binding request using the transaction ID, as defined in <a href="#RFC5389">[RFC5389]</a>, which then ties it to the candidate pair for which the Binding request was sent. This section defines additional procedures for processing Binding responses specific to this usage of STUN.  </p>
<h1 id="rfc.section.6.1.3.1"><a href="#rfc.section.6.1.3.1">6.1.3.1.</a> Failure Cases</h1>
<p id="rfc.section.6.1.3.1.p.1">If the STUN transaction generates a 487 (Role Conflict) error response, the agent checks whether it included the ICE-CONTROLLED or ICE-CONTROLLING attribute in the Binding request. If the request contained the ICE-CONTROLLED attribute, the agent MUST switch to the controlling role if it has not already done so. If the request contained the ICE-CONTROLLING attribute, the agent MUST switch to the controlled role if it has not already done so. Once it has switched, the agent MUST enqueue the candidate pair whose check generated the 487 into the triggered check queue. The state of that pair is set to Waiting. When the triggered check is sent, it will contain an ICE-CONTROLLING or ICE-CONTROLLED attribute reflecting its new role. Note, however, that the tie-breaker value MUST NOT be reselected.  </p>
<p id="rfc.section.6.1.3.1.p.2">A change in roles will require an agent to recompute pair priorities (<a href="#sec-comp-pair-prio">Section 5.1.3.2</a>), since those priorities are a function of controlling and controlled roles.  The change in role will also impact whether the agent is responsible for selecting nominated pairs and generating updated candidate information for sharing upon conclusion of ICE.  </p>
<p id="rfc.section.6.1.3.1.p.3">Agents MAY support receipt of ICMP errors for connectivity checks. If the STUN transaction generates an ICMP error, the agent sets the state of the pair to Failed.  If the STUN transaction generates a STUN error response that is unrecoverable (as defined in <a href="#RFC5389">[RFC5389]</a>) or times out, the agent sets the state of the pair to Failed.  </p>
<p id="rfc.section.6.1.3.1.p.4">The agent MUST check that the source IP address and port of the response equal the destination IP address and port to which the Binding request was sent, and that the destination IP address and port of the response match the source IP address and port from which the Binding request was sent.  In other words, the source and destination transport addresses in the request and responses are symmetric. If they are not symmetric, the agent sets the state of the pair to Failed.  </p>
<h1 id="rfc.section.6.1.3.2"><a href="#rfc.section.6.1.3.2">6.1.3.2.</a> Success Cases</h1>
<p id="rfc.section.6.1.3.2.p.1">A check is considered to be a success if all of the following are true: </p>

<ul>
  <li>The STUN transaction generated a success response.</li>
  <li>The source IP address and port of the response equals the destination IP address and port to which the Binding request was sent.</li>
  <li>The destination IP address and port of the response match the source IP address and port from which the Binding request was sent.</li>
</ul>
<h1 id="rfc.section.6.1.3.2.1"><a href="#rfc.section.6.1.3.2.1">6.1.3.2.1.</a> <a href="#sec-learn-peer-client" id="sec-learn-peer-client">Discovering Peer Reflexive Candidates</a></h1>
<p id="rfc.section.6.1.3.2.1.p.1">The agent checks the mapped address from the STUN response. If the transport address does not match any of the local candidates that the agent knows about, the mapped address represents a new candidate -- a peer reflexive candidate. Like other candidates, it has a type, base, priority, and foundation. They are computed as follows: </p>
<p/>

<ul>
  <li>Its type is equal to peer reflexive.</li>
  <li>Its base is set equal to the local candidate of the candidate pair from which the STUN check was sent.</li>
  <li>Its priority is set equal to the value of the PRIORITY attribute in the Binding request.</li>
  <li>Its foundation is selected as described in <a href="#sec-computing-foundations">Section 4.1.1.3</a>.</li>
</ul>
<p id="rfc.section.6.1.3.2.1.p.3">This peer reflexive candidate is then added to the list of local candidates for the media stream. Its username fragment and password are the same as all other local candidates for that media stream. However, the peer reflexive candidate is not paired with other remote candidates. This is not necessary; a valid pair will be generated from it momentarily based on the procedures in <a href="#sec-valid-cons">Section 6.1.3.2.2</a>. If an agent wishes to pair the peer reflexive candidate with other remote candidates besides the one in the valid pair that will be generated, the agent MAY generate an update the peer with the candidate information that includes the peer reflexive candidate. This will cause it to be paired with all other remote candidates.  </p>
<h1 id="rfc.section.6.1.3.2.2"><a href="#rfc.section.6.1.3.2.2">6.1.3.2.2.</a> <a href="#sec-valid-cons" id="sec-valid-cons">Constructing a Valid Pair</a></h1>
<p id="rfc.section.6.1.3.2.2.p.1">The agent constructs a candidate pair whose local candidate equals the mapped address of the response, and whose remote candidate equals the destination address to which the request was sent. This is called a valid pair, since it has been validated by a STUN connectivity check. The valid pair may equal the pair that generated the check, may equal a different pair in the check list, or may be a pair not currently on any check list. If the pair equals the pair that generated the check or is on a check list currently, it is also added to the VALID LIST, which is maintained by the agent for each media stream. This list is empty at the start of ICE processing, and fills as checks are performed, resulting in valid candidate pairs.  </p>
<p id="rfc.section.6.1.3.2.2.p.2">It will be very common that the pair will not be on any check list.  Recall that the check list has pairs whose local candidates are never server reflexive; those pairs had their local candidates converted to the base of the server reflexive candidates, and then pruned if they were redundant. When the response to the STUN check arrives, the mapped address will be reflexive if there is a NAT between the two. In that case, the valid pair will have a local candidate that doesn't match any of the pairs in the check list.  </p>
<p id="rfc.section.6.1.3.2.2.p.3">If the pair is not on any check list, the agent computes the priority for the pair based on the priority of each candidate, using the algorithm in <a href="#sec-forming">Section 5.1.3</a>. The priority of the local candidate depends on its type. If it is not peer reflexive, it is equal to the priority signaled for that candidate in the candidate exchange. If it is peer reflexive, it is equal to the PRIORITY attribute the agent placed in the Binding request that just completed. The priority of the remote candidate is taken from the candidate information of the peer. If the candidate does not appear there, then the check must have been a triggered check to a new remote candidate. In that case, the priority is taken as the value of the PRIORITY attribute in the Binding request that triggered the check that just completed. The pair is then added to the VALID LIST.  </p>
<h1 id="rfc.section.6.1.3.2.3"><a href="#rfc.section.6.1.3.2.3">6.1.3.2.3.</a> Updating Pair States</h1>
<p id="rfc.section.6.1.3.2.3.p.1">The agent sets the state of the pair that *generated* the check to Succeeded. Note that, the pair which *generated* the check may be different than the valid pair constructed in <a href="#sec-valid-cons">Section 6.1.3.2.2</a> as a consequence of the response. The success of this check might also cause the state of other checks to change as well. The agent MUST perform the following two steps: </p>
<p/>

<ol>
  <li>The agent changes the states for all other Frozen pairs for the same media stream and same foundation to Waiting. Typically, but not always, these other pairs will have different component IDs. </li>
  <li>If there is a pair in the valid list for every component of this media stream (where this is the actual number of components being used, in cases where the number of components signaled in the candidate exchange differs from initiating to responding agent), the success of this check may unfreeze checks for other media streams.  Note that this step is followed not just the first time the valid list under consideration has a pair for every component, but every subsequent time a check succeeds and adds yet another pair to that valid list. The agent examines the check list for each other media stream in turn: <ul><li>If the check list is active, the agent changes the state of all Frozen pairs in that check list whose foundation matches a pair in the valid list under consideration to Waiting. </li><li>If the check list is frozen, and there is at least one pair in the check list whose foundation matches a pair in the valid list under consideration, the state of all pairs in the check list whose foundation matches a pair in the valid list under consideration is set to Waiting. This will cause the check list to become active, and ordinary checks will begin for it, as described in <a href="#sec-periodic">Section 5.1.4</a>.</li><li>If the check list is frozen, and there are no pairs in the check list whose foundation matches a pair in the valid list under consideration, the agent <ul><li>groups together all of the pairs with the same foundation, and</li><li>for each group, sets the state of the pair with the lowest component ID to Waiting. If there is more than one such pair, the one with the highest-priority is used.  </li></ul><p> </p></li></ul><p> </p></li>
</ol>
<h1 id="rfc.section.6.1.3.2.4"><a href="#rfc.section.6.1.3.2.4">6.1.3.2.4.</a> Updating the Nominated Flag</h1>
<p id="rfc.section.6.1.3.2.4.p.1">If the agent was a controlling agent, and it had included a USE-CANDIDATE attribute in the Binding request, the valid pair generated from that check has its nominated flag set to true. This flag indicates that this valid pair should be used for media if it is the highest-priority one amongst those whose nominated flag is set. This may conclude ICE processing for this media stream or all media streams; see <a href="#sec-conclude">Section 7</a>.  </p>
<p id="rfc.section.6.1.3.2.4.p.2">If the agent is the controlled agent, the response may be the result of a triggered check that was sent in response to a request that itself had the USE-CANDIDATE attribute. This case is described in <a href="#sec-up-fav">Section 6.2.1.5</a>, and may now result in setting the nominated flag for the pair learned from the original request.  </p>
<h1 id="rfc.section.6.1.3.3"><a href="#rfc.section.6.1.3.3">6.1.3.3.</a> Check List and Timer State Updates</h1>
<p id="rfc.section.6.1.3.3.p.1">Regardless of whether the check was successful or failed, the completion of the transaction may require updating of check list and timer states.  </p>
<p id="rfc.section.6.1.3.3.p.2">If all of the pairs in the check list are now either in the Failed or Succeeded state: </p>

<ul>
  <li>If there is not a pair in the valid list for each component of the media stream, the state of the check list is set to Failed. </li>
  <li>For each frozen check list, the agent <ul><li>groups together all of the pairs with the same foundation, and</li><li>for each group, sets the state of the pair with the lowest component ID to Waiting. If there is more than one such pair, the one with the highest-priority is used.  </li></ul><p> </p></li>
</ul>
<p id="rfc.section.6.1.3.3.p.3">If none of the pairs in the check list are in the Waiting or Frozen state, the check list is no longer considered active, and will not count towards the value of N in the computation of timers for ordinary checks as described in <a href="#sec-periodic">Section 5.1.4</a>.  </p>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#sec-serverproc" id="sec-serverproc">STUN Server Procedures</a></h1>
<p id="rfc.section.6.2.p.1">An agent MUST be prepared to receive a Binding request on the base of each candidate it included in its most recent candidate exchange. This requirement holds even if the peer is a lite implementation.  </p>
<p id="rfc.section.6.2.p.2">The agent MUST use the short-term credential mechanism (i.e., the MESSAGE-INTEGRITY attribute) to authenticate the request and perform a message integrity check. Likewise, the short-term credential mechanism MUST be used for the response. The agent MUST consider the username to be valid if it consists of two values separated by a colon, where the first value is equal to the username fragment generated by the agent in an candidate exchange for a session in-progress. It is possible (and in fact very likely) that the initiating agent will receive a Binding request prior to receiving the candidates from its peer. If this happens, the agent MUST immediately generate a response (including computation of the mapped address as described in <a href="#sec-compute-mapped">Section 6.2.1.2</a>). The agent has sufficient information at this point to generate the response; the password from the peer is not required. Once the answer is received, it MUST proceed with the remaining steps required, namely, <a href="#sec-learn-peer-server">Section 6.2.1.3</a>, <a href="#sec-triggered">Section 6.2.1.4</a>, and <a href="#sec-up-fav">Section 6.2.1.5</a> for full implementations. In cases where multiple STUN requests are received before the answer, this may cause several pairs to be queued up in the triggered check queue.  </p>
<p id="rfc.section.6.2.p.3">An agent MUST NOT utilize the ALTERNATE-SERVER mechanism, and MUST NOT support the backwards-compatibility mechanisms to RFC 3489. It MUST utilize the FINGERPRINT mechanism.  </p>
<p id="rfc.section.6.2.p.4">If the agent is using Diffserv Codepoint markings <a href="#RFC2475">[RFC2475]</a> in its media packets, it SHOULD apply those same markings to its responses to Binding requests. The same would apply to any layer 2 markings the endpoint might be applying to media packets.  </p>
<h1 id="rfc.section.6.2.1"><a href="#rfc.section.6.2.1">6.2.1.</a> <a href="#sec-add-server-full" id="sec-add-server-full">Additional Procedures for Full Implementations</a></h1>
<p id="rfc.section.6.2.1.p.1">This subsection defines the additional server procedures applicable to full implementations.  </p>
<h1 id="rfc.section.6.2.1.1"><a href="#rfc.section.6.2.1.1">6.2.1.1.</a> Detecting and Repairing Role Conflicts</h1>
<p id="rfc.section.6.2.1.1.p.1">Normally, the rules for selection of a role in <a href="#sec-role">Section 5.1.2</a> will result in each agent selecting a different role -- one controlling and one controlled. However, in unusual call flows, typically utilizing third party call control, it is possible for both agents to select the same role. This section describes procedures for checking for this case and repairing it. These procedures apply only to usages of ICE that require conflict resolution. The usage document MUST specify whether this mechanism is needed.  </p>
<p id="rfc.section.6.2.1.1.p.2">An agent MUST examine the Binding request for either the ICE-CONTROLLING or ICE-CONTROLLED attribute. It MUST follow these procedures: </p>

<ul>
  <li>If neither ICE-CONTROLLING nor ICE-CONTROLLED is present in the request, the peer agent may have implemented a previous version of this specification. There may be a conflict, but it cannot be detected. </li>
  <li>If the agent is in the controlling role, and the ICE-CONTROLLING attribute is present in the request: <ul><li>If the agent's tie-breaker is larger than or equal to the contents of the ICE-CONTROLLING attribute, the agent generates a Binding error response and includes an ERROR-CODE attribute with a value of 487 (Role Conflict) but retains its role.  </li><li>If the agent's tie-breaker is less than the contents of the ICE-CONTROLLING attribute, the agent switches to the controlled role.  </li></ul><p> </p></li>
  <li>If the agent is in the controlled role, and the ICE-CONTROLLED attribute is present in the request: <ul><li>If the agent's tie-breaker is larger than or equal to the contents of the ICE-CONTROLLED attribute, the agent switches to the controlling role.  </li><li>If the agent's tie-breaker is less than the contents of the ICE-CONTROLLED attribute, the agent generates a Binding error response and includes an ERROR-CODE attribute with a value of 487 (Role Conflict) but retains its role.  </li></ul></li>
  <li>If the agent is in the controlled role and the ICE-CONTROLLING attribute was present in the request, or the agent was in the controlling role and the ICE-CONTROLLED attribute was present in the request, there is no conflict.  </li>
</ul>
<p id="rfc.section.6.2.1.1.p.3">A change in roles will require an agent to recompute pair priorities (<a href="#sec-comp-pair-prio">Section 5.1.3.2</a>), since those priorities are a function of controlling and controlled roles. The change in role will also impact whether the agent is responsible for selecting nominated pairs and initiating exchange with updated candidate information upon conclusion of ICE.  </p>
<p id="rfc.section.6.2.1.1.p.4">The remaining sections in <a href="#sec-add-server-full">Section 6.2.1</a> are followed if the server generated a successful response to the Binding request, even if the agent changed roles.  </p>
<h1 id="rfc.section.6.2.1.2"><a href="#rfc.section.6.2.1.2">6.2.1.2.</a> <a href="#sec-compute-mapped" id="sec-compute-mapped">Computing Mapped Address</a></h1>
<p id="rfc.section.6.2.1.2.p.1">For requests being received on a relayed candidate, the source transport address used for STUN processing (namely, generation of the XOR-MAPPED-ADDRESS attribute) is the transport address as seen by the TURN server. That source transport address will be present in the XOR-PEER-ADDRESS attribute of a Data Indication message, if the Binding request was delivered through a Data Indication. If the Binding request was delivered through a ChannelData message, the source transport address is the one that was bound to the channel.  </p>
<h1 id="rfc.section.6.2.1.3"><a href="#rfc.section.6.2.1.3">6.2.1.3.</a> <a href="#sec-learn-peer-server" id="sec-learn-peer-server">Learning Peer Reflexive Candidates</a></h1>
<p id="rfc.section.6.2.1.3.p.1">If the source transport address of the request does not match any existing remote candidates, it represents a new peer reflexive remote candidate. This candidate is constructed as follows: </p>

<ul>
  <li>The priority of the candidate is set to the PRIORITY attribute from the request.</li>
  <li>The type of the candidate is set to peer reflexive. </li>
  <li>The foundation of the candidate is set to an arbitrary value, different from the foundation for all other remote candidates. If any subsequent candidate exchanges contain this peer reflexive candidate, it will signal the actual foundation for the candidate.</li>
  <li>The component ID of this candidate is set to the component ID for the local candidate to which the request was sent.  </li>
</ul>

<p> </p>
<p id="rfc.section.6.2.1.3.p.2">This candidate is added to the list of remote candidates. However, the agent does not pair this candidate with any local candidates.  </p>
<h1 id="rfc.section.6.2.1.4"><a href="#rfc.section.6.2.1.4">6.2.1.4.</a> <a href="#sec-triggered" id="sec-triggered">Triggered Checks</a></h1>
<p id="rfc.section.6.2.1.4.p.1">Next, the agent constructs a pair whose local candidate is equal to the transport address on which the STUN request was received, and a remote candidate equal to the source transport address where the request came from (which may be the peer reflexive remote candidate that was just learned). The local candidate will either be a host candidate (for cases where the request was not received through a relay) or a relayed candidate (for cases where it is received through a relay).  The local candidate can never be a server reflexive candidate. Since both candidates are known to the agent, it can obtain their priorities and compute the candidate pair priority. This pair is then looked up in the check list. There can be one of several outcomes: </p>

<ul>
  <li>If the pair is already on the check list: <ul><li>If the state of that pair is Waiting or Frozen, a check for that pair is enqueued into the triggered check queue if not already present.  </li><li>If the state of that pair is In-Progress, the agent cancels the in-progress transaction. Cancellation means that the agent will not retransmit the request, will not treat the lack of response to be a failure, but will wait the duration of the transaction timeout for a response. In addition, the agent MUST create a new connectivity check for that pair (representing a new STUN Binding request transaction) by enqueueing the pair in the triggered check queue. The state of the pair is then changed to Waiting.  </li><li>If the state of the pair is Failed, it is changed to Waiting and the agent MUST create a new connectivity check for that pair (representing a new STUN Binding request transaction), by enqueueing the pair in the triggered check queue.  </li><li>If the state of that pair is Succeeded, nothing further is done. </li></ul><p> </p></li>
</ul>

<p> </p>
<p id="rfc.section.6.2.1.4.p.2">These steps are done to facilitate rapid completion of ICE when both agents are behind NAT.  </p>

<ul>
  <li>If the pair is not already on the check list: <ul><li>The pair is inserted into the check list based on its priority.</li><li>Its state is set to Waiting.</li><li>The pair is enqueued into the triggered check queue. </li></ul><p> </p></li>
</ul>

<p> </p>
<p id="rfc.section.6.2.1.4.p.3">When a triggered check is to be sent, it is constructed and processed as described in <a href="#sec-send-check">Section 6.1.2</a>. These procedures require the agent to know the transport address, username fragment, and password for the peer. The username fragment for the remote candidate is equal to the part after the colon of the USERNAME in the Binding request that was just received. Using that username fragment, the agent can check the candidates received from its peer (there may be more than one in cases of forking), and find this username fragment. The corresponding password is then selected.  </p>
<h1 id="rfc.section.6.2.1.5"><a href="#rfc.section.6.2.1.5">6.2.1.5.</a> <a href="#sec-up-fav" id="sec-up-fav">Updating the Nominated Flag</a></h1>
<p id="rfc.section.6.2.1.5.p.1">If the Binding request received by the agent had the USE-CANDIDATE attribute set, and the agent is in the controlled role, the agent looks at the state of the pair computed in <a href="#sec-triggered">Section 6.2.1.4</a>: </p>

<ul>
  <li>If the state of this pair is Succeeded, it means that the check generated by this pair produced a successful response. This would have caused the agent to construct a valid pair when that success response was received (see <a href="#sec-valid-cons">Section 6.1.3.2.2</a>). The agent now sets the nominated flag in the valid pair to true. This may end ICE processing for this media stream; see <a href="#sec-conclude">Section 7</a>.  </li>
  <li>If the state of this pair is In-Progress, if its check produces a successful result, the resulting valid pair has its nominated flag set when the response arrives. This may end ICE processing for this media stream when it arrives; see <a href="#sec-conclude">Section 7</a>.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.6.2.2"><a href="#rfc.section.6.2.2">6.2.2.</a> Additional Procedures for Lite Implementations</h1>
<p id="rfc.section.6.2.2.p.1">If the check that was just received contained a USE-CANDIDATE attribute, the agent constructs a candidate pair whose local candidate is equal to the transport address on which the request was received, and whose remote candidate is equal to the source transport address of the request that was received. This candidate pair is assigned an arbitrary priority, and placed into a list of valid candidates called the valid list. The agent sets the nominated flag for that pair to true. ICE processing is considered complete for a media stream if the valid list contains a candidate pair for each component.  </p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#sec-conclude" id="sec-conclude">Concluding ICE Processing</a></h1>
<p id="rfc.section.7.p.1">This section describes how an agent completes ICE.  </p>
<h1 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#sec-conclude-full" id="sec-conclude-full">Procedures for Full Implementations</a></h1>
<p id="rfc.section.7.1.p.1">Concluding ICE involves nominating pairs by the controlling agent and updating of state machinery.  </p>
<h1 id="rfc.section.7.1.1"><a href="#rfc.section.7.1.1">7.1.1.</a> <a href="#sec-choose-favor" id="sec-choose-favor">Nominating Pairs</a></h1>
<p id="rfc.section.7.1.1.p.1">The controlling agent nominates pairs to be selected by ICE by using one of two techniques: regular nomination or aggressive nomination. If its peer has a lite implementation, an agent MUST use a regular nomination algorithm. If its peer is using ICE options (present in an ice-options attribute from the peer) that the agent does not understand, the agent MUST use a regular nomination algorithm. If its peer is a full implementation and isn't using any ICE options or is using ICE options understood by the agent, the agent MAY use either the aggressive or the regular nomination algorithm. However, the regular algorithm is RECOMMENDED since it provides greater stability.  </p>
<h1 id="rfc.section.7.1.1.1"><a href="#rfc.section.7.1.1.1">7.1.1.1.</a> Regular Nomination</h1>
<p id="rfc.section.7.1.1.1.p.1">With regular nomination, the agent lets some number of checks complete, each of which omit the USE-CANDIDATE attribute. Once one or more checks complete successfully for a component of a media stream, valid pairs are generated and added to the valid list. The agent lets the checks continue until some stopping criterion is met, and then picks amongst the valid pairs based on an evaluation criterion. The criteria for stopping the checks and for evaluating the valid pairs is entirely a matter of local optimization.  </p>
<p id="rfc.section.7.1.1.1.p.2">When the controlling agent selects the valid pair, it repeats the check that produced this valid pair (by enqueueing the pair that generated the check into the triggered check queue), this time with the USE-CANDIDATE attribute. This check should succeed (since the previous did), causing the nominated flag of that and only that pair to be set. Consequently, there will be only a single nominated pair in the valid list for each component, and when the state of the check list moves to completed, that exact pair is selected by ICE for sending and receiving media for that component.  </p>
<p id="rfc.section.7.1.1.1.p.3">Regular nomination provides the most flexibility, since the agent has control over the stopping and selection criteria for checks. The only requirement is that the agent MUST eventually pick one and only one candidate pair and generate a check for that pair with the USE-CANDIDATE attribute present. Regular nomination also improves ICE's resilience to variations in implementation (see <a href="#sec-futureproof">Section 11</a>). Regular nomination is also more stable, allowing both agents to converge on a single pair for media without any transient selections, which can happen with the aggressive algorithm. The drawback of regular nomination is that it is guaranteed to increase latencies because it requires an additional check to be done.  </p>
<h1 id="rfc.section.7.1.1.2"><a href="#rfc.section.7.1.1.2">7.1.1.2.</a> Aggressive Nomination</h1>
<p id="rfc.section.7.1.1.2.p.1">With aggressive nomination, the controlling agent includes the USE-CANDIDATE attribute in every check it sends. Once the first check for a component succeeds, it will be added to the valid list and have its nominated flag set. When all components have a nominated pair in the valid list, media can begin to flow using the highest-priority nominated pair. However, because the agent included the USE-CANDIDATE attribute in all of its checks, another check may yet complete, causing another valid pair to have its nominated flag set. ICE always selects the highest-priority nominated candidate pair from the valid list as the one used for media. Consequently, the selected pair may actually change briefly as ICE checks complete, resulting in a set of transient selections until it stabilizes.  </p>
<p id="rfc.section.7.1.1.2.p.2">If certain connectivity check messages are lost, ICE agents using aggressive nomination may end up with different views on the selected candidate pair. In this case, if a security protocol that is able to authenticate the communicating parties (e.g., DTLS) is used, the controlled agent may receive valid secured traffic or handshake initialization originating from the controlling agent on a candidate pair that is different from the one the controlled agent considers as the selected pair. If this happens, the controlled agent MUST consider the pair with the secured traffic as the correct selected pair. If such security protocol is not used, both agents SHOULD continue sending connectivity check messages on the selected pair even after a pair has already been selected for use. In order to prevent the problem described here, at least one check from both agents needs to fully succeed on the selected pair.  </p>
<h1 id="rfc.section.7.1.2"><a href="#rfc.section.7.1.2">7.1.2.</a> <a href="#sec-conc-state" id="sec-conc-state">Updating States</a></h1>
<p id="rfc.section.7.1.2.p.1">For both controlling and controlled agents, the state of ICE processing depends on the presence of nominated candidate pairs in the valid list and on the state of the check list. Note that, at any time, more than one of the following cases can apply: </p>
<p/>

<ul>
  <li>If there are no nominated pairs in the valid list for a media stream and the state of the check list is Running, ICE processing continues.  </li>
  <li>If there is at least one nominated pair in the valid list for a media stream and the state of the check list is Running: <ul><li>The agent MUST remove all Waiting and Frozen pairs in the check list and triggered check queue for the same component as the nominated pairs for that media stream.  </li><li>If an In-Progress pair in the check list is for the same component as a nominated pair, the agent SHOULD cease retransmissions for its check if its pair priority is lower than the lowest-priority nominated pair for that component.  </li></ul><p> </p></li>
  <li>Once there is at least one nominated pair in the valid list for every component of at least one media stream and the state of the check list is Running: <ul><li>The agent MUST change the state of processing for its check list for that media stream to Completed. </li><li>The agent MUST continue to respond to any checks it may still receive for that media stream, and MUST perform triggered checks if required by the processing of <a href="#sec-serverproc">Section 6.2</a>.  </li><li>The agent MUST continue retransmitting any In-Progress checks for that check list.</li><li>The agent MAY begin transmitting media for this media stream as described in <a href="#sec-send-media">Section 10.1</a>.  </li></ul><p> </p></li>
  <li>Once the state of each check list is Completed: <ul><li>The agent sets the state of ICE processing overall to Completed.</li><li>If the controlling agent is using an aggressive nomination algorithm, this may result in several updated candidate exchanges as the pairs selected for media change. An agent MAY delay sending its candidates for a brief interval (one second is RECOMMENDED) in order to allow the selected pairs to stabilize.</li></ul><p> </p></li>
  <li>If the state of the check list is Failed, ICE has not been able to complete for this media stream. The correct behavior depends on the state of the check lists for other media streams: <ul><li>If all check lists are Failed, ICE processing overall is considered to be in the Failed state, and the agent SHOULD consider the session a failure, SHOULD NOT restart ICE, and the controlling agent SHOULD terminate the entire session. </li><li>If at least one of the check lists for other media streams is Completed, the controlling agent SHOULD remove the failed media stream from the session while sending updated candidate list to its peer.</li><li>If none of the check lists for other media streams are Completed, but at least one is Running, the agent SHOULD let ICE continue.</li></ul><p> </p></li>
</ul>
<h1 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#sec-lite-conclude" id="sec-lite-conclude">Procedures for Lite Implementations</a></h1>
<p id="rfc.section.7.2.p.1">Concluding ICE for a lite implementation is relatively straightforward. There are two cases to consider: </p>

<ul class="empty">
  <li>The implementation is lite, and its peer is full. </li>
  <li>The implementation is lite, and its peer is lite. </li>
</ul>
<p id="rfc.section.7.2.p.2">The effect of ICE concluding is that the agent can free any allocated host candidates that were not utilized by ICE, as described in <a href="#sec-freeing">Section 7.3</a>.  </p>
<h1 id="rfc.section.7.2.1"><a href="#rfc.section.7.2.1">7.2.1.</a> Peer Is Full</h1>
<p id="rfc.section.7.2.1.p.1">In this case, the agent will receive connectivity checks from its peer. When an agent has received a connectivity check that includes the USE-CANDIDATE attribute for each component of a media stream, the state of ICE processing for that media stream moves from Running to Completed. When the state of ICE processing for all media streams is Completed, the state of ICE processing overall is Completed.  </p>
<p id="rfc.section.7.2.1.p.2">The lite implementation will never itself determine that ICE processing has failed for a media stream; rather, the full peer will make that determination and then remove or restart the failed media stream as part of subsequent candidate exchange process.  </p>
<h1 id="rfc.section.7.2.2"><a href="#rfc.section.7.2.2">7.2.2.</a> <a href="#sec-lite-conc2" id="sec-lite-conc2">Peer Is Lite</a></h1>
<p id="rfc.section.7.2.2.p.1">Once the candidate exchange has completed, both agents examine their candidates and those of its peer. For each media stream, each agent pairs up its own candidates with the candidates of its peer for that media stream. Two candidates are paired up when they are for the same component, utilize the same transport protocol (UDP in this specification), and are from the same IP address family (IPv4 or IPv6).  </p>

<ul>
  <li>If there is a single pair per component, that pair is added to the Valid list. If all of the components for a media stream had one pair, the state of ICE processing for that media stream is set to Completed. If all media streams are Completed, the state of ICE processing is set to Completed overall. This will always be the case for implementations that are IPv4-only.  </li>
  <li>If there is more than one pair per component: <ul><li>The agent MUST select a pair based on local policy. Since this case only arises for IPv6, it is RECOMMENDED that an agent follow the procedures of RFC 6724 <a href="#RFC6724">[RFC6724]</a> to select a single pair. </li><li>The agent adds the selected pair for each component to the valid list. As described in <a href="#sec-send-media">Section 10.1</a>, this will permit media to begin flowing. However, it is possible (and in fact likely) that both agents have chosen different pairs. </li><li>To reconcile this, the controlling agent MUST send updated candidate list which will include the remote-candidates attribute.  </li><li>The agent MUST NOT update the state of ICE processing until after the candidate exchange completes. Then the controlling agent MUST change the state of ICE processing to Completed for all media streams, and the state of ICE processing overall to Completed.  </li></ul></li>
</ul>
<h1 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a> <a href="#sec-freeing" id="sec-freeing">Freeing Candidates</a></h1>
<h1 id="rfc.section.7.3.1"><a href="#rfc.section.7.3.1">7.3.1.</a> Full Implementation Procedures</h1>
<p id="rfc.section.7.3.1.p.1">The procedures in <a href="#sec-conclude">Section 7</a> require that an agent continue to listen for STUN requests and continue to generate triggered checks for a media stream, even once processing for that stream completes. The rules in this section describe when it is safe for an agent to cease sending or receiving checks on a candidate that was not selected by ICE, and then free the candidate.  </p>
<h1 id="rfc.section.7.3.2"><a href="#rfc.section.7.3.2">7.3.2.</a> Lite Implementation Procedures</h1>
<p id="rfc.section.7.3.2.p.1">A lite implementation MAY free candidates not selected by ICE as soon as ICE processing has reached the Completed state for all peers for all media streams using those candidates.  </p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> ICE Restarts</h1>
<p id="rfc.section.8.p.1">An agent MAY restart ICE processing for an existing media stream.  An ICE restart, as the name implies, will cause all previous states of ICE processing to be flushed and checks to start anew.  The only difference between an ICE restart and a brand new media session is that, during the restart, media can continue to be sent to the previously validated pair.  </p>
<p id="rfc.section.8.p.2">An agent MUST restart ICE for a media stream if:</p>
<p/>

<ul>
  <li>The candidate(s) is being generated for the purposes of changing the target of the media stream.  In other words, if an agent wants to generate an updated candidate information that, had ICE not been in use, would result in a new value for the destination of a media component.  </li>
  <li>An agent is changing its implementation level.  This typically only happens in third party call control use cases, where the entity performing the signaling is not the entity receiving the media, and it has changed the target of media mid-session to another entity that has a different ICE implementation.  </li>
</ul>

<p> </p>
<p id="rfc.section.8.p.4">To restart ICE, an agent MUST change both the password and the user name fragment for the media stream when exchanging the candidates.  The new candidate set MAY include some, none, or all of the previous candidates for that stream and MAY include a totally new set of candidates.  </p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#sec-keepalives" id="sec-keepalives">Keepalives</a></h1>
<p id="rfc.section.9.p.1">All endpoints MUST send keepalives for each media session. These keepalives serve the purpose of keeping NAT bindings alive for the media session.  These keepalives MUST be sent even if ICE is not being utilized for the session at all. The keepalive SHOULD be sent using a format that is supported by its peer. ICE endpoints allow for STUN-based keepalives for UDP streams, and as such, STUN keepalives MUST be used when an agent is a full ICE implementation and is communicating with a peer that supports ICE (lite or full).  If the peer does not support ICE, the choice of a packet format for keepalives is a matter of local implementation. A format that allows packets to easily be sent in the absence of actual media content is RECOMMENDED. Examples of formats that readily meet this goal are RTP No-Op <a href="#I-D.ietf-avt-rtp-no-op">[I-D.ietf-avt-rtp-no-op]</a>, and in cases where both sides support it, RTP comfort noise <a href="#RFC3389">[RFC3389]</a>. If the peer doesn't support any formats that are particularly well suited for keepalives, an agent SHOULD send RTP packets with an incorrect version number, or some other form of error that would cause them to be discarded by the peer. </p>
<p id="rfc.section.9.p.2">If there has been no packet sent on the candidate pair ICE is using for a media component for Tr seconds (where packets include those defined for the component (RTP or RTCP) and previous keepalives), an agent MUST generate a keepalive on that pair.  Tr SHOULD be configurable and SHOULD have a default of 15 seconds. Tr MUST NOT be configured to less than 15 seconds. Alternatively, if an agent has a dynamic way to discover the binding lifetimes of the intervening NATs, it can use that value to determine Tr.  Administrators deploying ICE in more controlled networking environments SHOULD set Tr to the longest duration possible in their environment.  </p>
<p id="rfc.section.9.p.3">If STUN is being used for keepalives, a STUN Binding Indication is used <a href="#RFC5389">[RFC5389]</a>. The Indication MUST NOT utilize any authentication mechanism. It SHOULD contain the FINGERPRINT attribute to aid in demultiplexing, but SHOULD NOT contain any other attributes. It is used solely to keep the NAT bindings alive.  The Binding Indication is sent using the same local and remote candidates that are being used for media. Though Binding Indications are used for keepalives, an agent MUST be prepared to receive a connectivity check as well. If a connectivity check is received, a response is generated as discussed in <a href="#RFC5389">[RFC5389]</a>, but there is no impact on ICE processing otherwise.  </p>
<p id="rfc.section.9.p.4">An agent MUST begin the keepalive processing once ICE has selected candidates for usage with media, or media begins to flow, whichever happens first. Keepalives end once the session terminates or the media stream is removed.  </p>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> Media Handling</h1>
<h1 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1.</a> <a href="#sec-send-media" id="sec-send-media">Sending Media</a></h1>
<p id="rfc.section.10.1.p.1">Procedures for sending media differ for full and lite implementations.  </p>
<h1 id="rfc.section.10.1.1"><a href="#rfc.section.10.1.1">10.1.1.</a> Procedures for Full Implementations</h1>
<p id="rfc.section.10.1.1.p.1">Agents always send media using a candidate pair, called the selected candidate pair. An agent will send media to the remote candidate in the selected pair (setting the destination address and port of the packet equal to that remote candidate), and will send it from the local candidate of the selected pair. When the local candidate is server or peer reflexive, media is originated from the base. Media sent from a relayed candidate is sent from the base through that TURN server, using procedures defined in <a href="#RFC5766">[RFC5766]</a>.  </p>
<p id="rfc.section.10.1.1.p.2">If the local candidate is a relayed candidate, it is RECOMMENDED that an agent create a channel on the TURN server towards the remote candidate.  This is done using the procedures for channel creation as defined in Section 11 of <a href="#RFC5766">[RFC5766]</a>.  </p>
<p id="rfc.section.10.1.1.p.3">The selected pair for a component of a media stream is: </p>

<ul>
  <li>empty if the state of the check list for that media stream is Running, and there is no previous selected pair for that component due to an ICE restart </li>
  <li>equal to the previous selected pair for a component of a media stream if the state of the check list for that media stream is Running, and there was a previous selected pair for that component due to an ICE restart </li>
  <li>equal to the highest-priority nominated pair for that component in the valid list if the state of the check list is Completed </li>
</ul>

<p> </p>
<p id="rfc.section.10.1.1.p.4">If the selected pair for at least one component of a media stream is empty, an agent MUST NOT send media for any component of that media stream. If the selected pair for each component of a media stream has a value, an agent MAY send media for all components of that media stream.  </p>
<h1 id="rfc.section.10.1.2"><a href="#rfc.section.10.1.2">10.1.2.</a> Procedures for Lite Implementations</h1>
<p id="rfc.section.10.1.2.p.1">A lite implementation MUST NOT send media until it has a Valid list that contains a candidate pair for each component of that media stream. Once that happens, the agent MAY begin sending media packets. To do that, it sends media to the remote candidate in the pair (setting the destination address and port of the packet equal to that remote candidate), and will send it from the local candidate.  </p>
<h1 id="rfc.section.10.1.3"><a href="#rfc.section.10.1.3">10.1.3.</a> Procedures for All Implementations</h1>
<p id="rfc.section.10.1.3.p.1">ICE has interactions with jitter buffer adaptation mechanisms. An RTP stream can begin using one candidate, and switch to another one, though this happens rarely with ICE. The newer candidate may result in RTP packets taking a different path through the network -- one with different delay characteristics. As discussed below, agents are encouraged to re-adjust jitter buffers when there are changes in source or destination address of media packets. Furthermore, many audio codecs use the marker bit to signal the beginning of a talkspurt, for the purposes of jitter buffer adaptation. For such codecs, it is RECOMMENDED that the sender set the marker bit <a href="#RFC3550">[RFC3550]</a> when an agent switches transmission of media from one candidate pair to another.  </p>
<h1 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2.</a> <a href="#sec-recv-media" id="sec-recv-media">Receiving Media</a></h1>
<p id="rfc.section.10.2.p.1">ICE implementations MUST be prepared to receive media on each component on any candidates provided for that component in the most recent candidate exchange (in the case of RTP, this would include both RTP and RTCP if candidates were provided for both).  </p>
<p id="rfc.section.10.2.p.2">It is RECOMMENDED that, when an agent receives an RTP packet with a new source or destination IP address for a particular media stream, that the agent re-adjust its jitter buffers.  </p>
<p id="rfc.section.10.2.p.3">RFC 3550 <a href="#RFC3550">[RFC3550]</a> describes an algorithm in Section 8.2 for detecting synchronization source (SSRC) collisions and loops. These algorithms are based, in part, on seeing different source transport addresses with the same SSRC. However, when ICE is used, such changes will sometimes occur as the media streams switch between candidates. An agent will be able to determine that a media stream is from the same peer as a consequence of the STUN exchange that proceeds media transmission. Thus, if there is a change in source transport address, but the media packets come from the same peer agent, this SHOULD NOT be treated as an SSRC collision.  </p>
<h1 id="rfc.section.11"><a href="#rfc.section.11">11.</a> <a href="#sec-futureproof" id="sec-futureproof">Extensibility Considerations</a></h1>
<p id="rfc.section.11.p.1">This specification makes very specific choices about how both agents in a session coordinate to arrive at the set of candidate pairs that are selected for media. It is anticipated that future specifications will want to alter these algorithms, whether they are simple changes like timer tweaks or larger changes like a revamp of the priority algorithm. When such a change is made, providing interoperability between the two agents in a session is critical.  </p>
<p id="rfc.section.11.p.2">First, ICE provides the ice-options attribute. Each extension or change to ICE is associated with a token. When an agent supporting such an extension or change triggers candidate exchange, it MUST include the token for that extension in this attribute. This allows each side to know what the other side is doing. This attribute MUST NOT be present if the agent doesn't support any ICE extensions or changes.  </p>
<p id="rfc.section.11.p.3">One of the complications in achieving interoperability is that ICE relies on a distributed algorithm running on both agents to converge on an agreed set of candidate pairs. If the two agents run different algorithms, it can be difficult to guarantee convergence on the same candidate pairs. The regular nomination procedure described in <a href="#sec-conclude">Section 7</a> eliminates some of the tight coordination by delegating the selection algorithm completely to the controlling agent. Consequently, when a controlling agent is communicating with a peer that supports options it doesn't know about, the agent MUST run a regular nomination algorithm. When regular nomination is used, ICE will converge perfectly even when both agents use different pair prioritization algorithms. One of the keys to such convergence is triggered checks, which ensure that the nominated pair is validated by both agents. Consequently, any future ICE enhancements MUST preserve triggered checks.  </p>
<p id="rfc.section.11.p.4">ICE is also extensible to other media streams beyond RTP, and for transport protocols beyond UDP. Extensions to ICE for non-RTP media streams need to specify how many components they utilize, and assign component IDs to them, starting at 1 for the most important component ID. Specifications for new transport protocols must define how, if at all, various steps in the ICE processing differ from UDP.  </p>
<h1 id="rfc.section.12"><a href="#rfc.section.12">12.</a> <a href="#sec-ta" id="sec-ta">Setting Ta and RTO</a></h1>
<p id="rfc.section.12.p.1">During the gathering phase of ICE (<a href="#sec-gathering">Section 4.1.1</a>) and while ICE is performing connectivity checks (<a href="#sec-connectivity_check">Section 6</a>), an agent sends STUN and TURN transactions. These transactions are paced at a rate of one every Ta milliseconds, and utilize a specific RTO.  This section describes how the values of Ta and RTO are computed.  This computation depends on whether ICE is being used with a real-time media stream (such as RTP) or something else. When ICE is used for a stream with a known maximum bandwidth, the computation in <a href="#sec-rtp-based">Section 12.1</a> MAY be followed to rate-control the ICE exchanges. For all other streams, the computation in <a href="#sec-non-rtp">Section 12.2</a> MUST be followed.  </p>
<h1 id="rfc.section.12.1"><a href="#rfc.section.12.1">12.1.</a> <a href="#sec-rtp-based" id="sec-rtp-based">Real-time Media Streams</a></h1>
<p id="rfc.section.12.1.p.1">The values of RTO and Ta change during the lifetime of ICE processing. One set of values applies during the gathering phase, and the other, for connectivity checks.  </p>
<p id="rfc.section.12.1.p.2">The value of Ta SHOULD be configurable, and SHOULD have a default of: </p>
<pre>


For each media stream i:
 Ta_i = (stun_packet_size / rtp_packet_size) * rtp_ptime

                        1
  Ta = MAX (20ms, ------------------- )
                        k
                      ----
                      \        1
                       &gt;    ------
                      /       Ta_i
                      ----
                       i=1

</pre>
<p id="rfc.section.12.1.p.3">where k is the number of media streams. During the gathering phase, Ta is computed based on the number of media streams the agent has indicated in the candidate information, and the RTP packet size and RTP ptime are those of the most preferred codec for each media stream. Once the candidate exchange is completed, the agent recomputes Ta to pace the connectivity checks. In that case, the value of Ta is based on the number of media streams that will actually be used in the session, and the RTP packet size and RTP ptime are those of the most preferred codec with which the agent will send.  </p>
<p id="rfc.section.12.1.p.4">In addition, the retransmission timer for the STUN transactions, RTO, defined in <a href="#RFC5389">[RFC5389]</a>, SHOULD be configurable and during the gathering phase, SHOULD have a default of: </p>
<pre>

  RTO = MAX (100ms, Ta * (number of pairs))
</pre>
<p id="rfc.section.12.1.p.5">where the number of pairs refers to the number of pairs of candidates with STUN or TURN servers.  </p>
<p id="rfc.section.12.1.p.6">For connectivity checks, RTO SHOULD be configurable and SHOULD have a default of: </p>
<pre>

  RTO = MAX (100ms, Ta*N * (Num-Waiting + Num-In-Progress))
</pre>
<p id="rfc.section.12.1.p.7">where Num-Waiting is the number of checks in the check list in the Waiting state, and Num-In-Progress is the number of checks in the In-Progress state. Note that the RTO will be different for each transaction as the number of checks in the Waiting and In-Progress states change.  </p>
<p id="rfc.section.12.1.p.8">These formulas are aimed at causing STUN transactions to be paced at the same rate as media. This ensures that ICE will work properly under the same network conditions needed to support the media as well.  See <a href="#sec-pacing">Appendix B.1</a> for additional discussion and motivations.  Because of this pacing, it will take a certain amount of time to obtain all of the server reflexive and relayed candidates. Implementations should be aware of the time required to do this, and if the application requires a time budget, limit the number of candidates that are gathered.  </p>
<p id="rfc.section.12.1.p.9">The formulas result in a behavior whereby an agent will send its first packet for every single connectivity check before performing a retransmit. This can be seen in the formulas for the RTO (which represents the retransmit interval). Those formulas scale with N, the number of checks to be performed. As a result of this, ICE maintains a nicely constant rate, but becomes more sensitive to packet loss. The loss of the first single packet for any connectivity check is likely to cause that pair to take a long time to be validated, and instead, a lower-priority check (but one for which there was no packet loss) is much more likely to complete first. This results in ICE performing sub-optimally, choosing lower-priority pairs over higher-priority pairs. Implementors should be aware of this consequence, but still should utilize the timer values described here.  </p>
<h1 id="rfc.section.12.2"><a href="#rfc.section.12.2">12.2.</a> <a href="#sec-non-rtp" id="sec-non-rtp">Non-real-time Sessions</a></h1>
<p id="rfc.section.12.2.p.1">In cases where ICE is used to establish some kind of session that is not real time, and has no fixed rate associated with it that is known to work on the network in which ICE is deployed, Ta and RTO revert to more conservative values.  Ta SHOULD be configurable, SHOULD have a default of 500 ms, and MUST NOT be configurable to be less than 500 ms.  </p>
<p id="rfc.section.12.2.p.2">If other Ta value than the default is used, the agent MUST indicate the value it prefers to use in the ICE exchange. Both agents MUST use the higher out of the two proposed values. </p>
<p id="rfc.section.12.2.p.3">In addition, the retransmission timer for the STUN transactions, RTO, SHOULD be configurable and during the gathering phase, SHOULD have a default of: </p>
<pre>

  RTO = MAX (500ms, Ta * (number of pairs))
</pre>
<p id="rfc.section.12.2.p.4">where the number of pairs refers to the number of pairs of candidates with STUN or TURN servers.  </p>
<p id="rfc.section.12.2.p.5">For connectivity checks, RTO SHOULD be configurable and SHOULD have a default of: </p>
<pre>

  RTO = MAX (500ms, Ta*N * (Num-Waiting + Num-In-Progress))
</pre>
<h1 id="rfc.section.13"><a href="#rfc.section.13">13.</a> <a href="#sec-example" id="sec-example">Example</a></h1>
<p id="rfc.section.13.p.1">The example is based on the simplified topology of <a href="#fig-ex-topo">Figure 9</a>.  </p>
<div id="rfc.figure.9"/>
<div id="fig-ex-topo"/>
<pre>

                         +-------+
                         |STUN   |
                         |Server |
                         +-------+
                             |
                  +---------------------+
                  |                     |
                  |      Internet       |
                  |                     |
                  +---------------------+
                    |                |
                    |                |
             +---------+             |
             |   NAT   |             |
             +---------+             |
                  |                  |
                  |                  |
               +-----+            +-----+
               |  L  |            |  R  |
               +-----+            +-----+
</pre>
<p class="figure">Figure 9: Example Topology</p>
<p id="rfc.section.13.p.2">Two agents, L and R, are using ICE. Both are full-mode ICE implementations and use aggressive nomination when they are controlling. Both agents have a single IPv4 address. For agent L, it is 10.0.1.1 in private address space <a href="#RFC1918">[RFC1918]</a>, and for agent R, 192.0.2.1 on the public Internet. Both are configured with the same STUN server (shown in this example for simplicity, although in practice the agents do not need to use the same STUN server), which is listening for STUN Binding requests at an IP address of 192.0.2.2 and port 3478. TURN servers are not used in this example. Agent L is behind a NAT, and agent R is on the public Internet. The NAT has an endpoint independent mapping property and an address dependent filtering property. The public side of the NAT has an IP address of 192.0.2.3.  </p>
<p id="rfc.section.13.p.3">To facilitate understanding, transport addresses are listed using variables that have mnemonic names. The format of the name is entity-type-seqno, where entity refers to the entity whose IP address the transport address is on, and is one of "L", "R", "STUN", or "NAT". The type is either "PUB" for transport addresses that are public, and "PRIV" for transport addresses that are private. Finally, seq-no is a sequence number that is different for each transport address of the same type on a particular entity. Each variable has an IP address and port, denoted by varname.IP and varname.PORT, respectively, where varname is the name of the variable. </p>
<p id="rfc.section.13.p.4">The STUN server has advertised transport address STUN-PUB-1 (which is 192.0.2.2:3478).  </p>
<p id="rfc.section.13.p.5">In the call flow itself, STUN messages are annotated with several attributes. The "S=" attribute indicates the source transport address of the message. The "D=" attribute indicates the destination transport address of the message. The "MA=" attribute is used in STUN Binding response messages and refers to the mapped address. "USE-CAND" implies the presence of the USE-CANDIDATE attribute.  </p>
<p id="rfc.section.13.p.6">The call flow examples omit STUN authentication operations and RTCP, and focus on RTP for a single media stream between two full implementations.  </p>
<div id="rfc.figure.10"/>
<div id="fig:basic-ex"/>
<pre>

          L             NAT           STUN             R
          |RTP STUN alloc.              |              |
          |(1) STUN Req  |              |              |
          |S=$L-PRIV-1   |              |              |
          |D=$STUN-PUB-1 |              |              |
          |-------------&gt;|              |              |
          |              |(2) STUN Req  |              |
          |              |S=$NAT-PUB-1  |              |
          |              |D=$STUN-PUB-1 |              |
          |              |-------------&gt;|              |
          |              |(3) STUN Res  |              |
          |              |S=$STUN-PUB-1 |              |
          |              |D=$NAT-PUB-1  |              |
          |              |MA=$NAT-PUB-1 |              |
          |              |&lt;-------------|              |
          |(4) STUN Res  |              |              |
          |S=$STUN-PUB-1 |              |              |
          |D=$L-PRIV-1   |              |              |
          |MA=$NAT-PUB-1 |              |              |
          |&lt;-------------|              |              |
          |(5) L's Candidate Information|              |
          |-------------------------------------------&gt;|
          |              |              |              | RTP STUN
          |              |              |              | alloc.
          |              |              |(6) STUN Req  |
          |              |              |S=$R-PUB-1    |
          |              |              |D=$STUN-PUB-1 |
          |              |              |&lt;-------------|
          |              |              |(7) STUN Res  |
          |              |              |S=$STUN-PUB-1 |
          |              |              |D=$R-PUB-1    |
          |              |              |MA=$R-PUB-1   |
          |              |              |-------------&gt;|
          |(8) R's Candidate Information|              |
          |&lt;-------------------------------------------|
          |              |(9) Bind Req  |              |Begin
          |              |S=$R-PUB-1    |              |Connectivity
          |              |D=L-PRIV-1    |              |Checks
          |              |&lt;----------------------------|
          |              |Dropped       |              |
          |(10) Bind Req |              |              |
          |S=$L-PRIV-1   |              |              |
          |D=$R-PUB-1    |              |              |
          |USE-CAND      |              |              |
          |-------------&gt;|              |              |
          |              |(11) Bind Req |              |
          |              |S=$NAT-PUB-1  |              |
          |              |D=$R-PUB-1    |              |
          |              |USE-CAND      |              |
          |              |----------------------------&gt;|
          |              |(12) Bind Res |              |
          |              |S=$R-PUB-1    |              |
          |              |D=$NAT-PUB-1  |              |
          |              |MA=$NAT-PUB-1 |              |
          |              |&lt;----------------------------|
          |(13) Bind Res |              |              |
          |S=$R-PUB-1    |              |              |
          |D=$L-PRIV-1   |              |              |
          |MA=$NAT-PUB-1 |              |              |
          |&lt;-------------|              |              |
          |RTP flows     |              |              |
          |              |(14) Bind Req |              |
          |              |S=$R-PUB-1    |              |
          |              |D=$NAT-PUB-1  |              |
          |              |&lt;----------------------------|
          |(15) Bind Req |              |              |
          |S=$R-PUB-1    |              |              |
          |D=$L-PRIV-1   |              |              |
          |&lt;-------------|              |              |
          |(16) Bind Res |              |              |
          |S=$L-PRIV-1   |              |              |
          |D=$R-PUB-1    |              |              |
          |MA=$R-PUB-1   |              |              |
          |-------------&gt;|              |              |
          |              |(17) Bind Res |              |
          |              |S=$NAT-PUB-1  |              |
          |              |D=$R-PUB-1    |              |
          |              |MA=$R-PUB-1   |              |
          |              |----------------------------&gt;|
          |              |              |              |RTP flows

</pre>
<p class="figure">Figure 10: Example Flow</p>
<p id="rfc.section.13.p.7">First, agent L obtains a host candidate from its local IP address (not shown), and from that, sends a STUN Binding request to the STUN server to get a server reflexive candidate (messages 1-4). Recall that the NAT has the address and port independent mapping property. Here, it creates a binding of NAT-PUB-1 for this UDP request, and this becomes the server reflexive candidate for RTP.  </p>
<p id="rfc.section.13.p.8">Agent L sets a type preference of 126 for the host candidate and 100 for the server reflexive. The local preference is 65535. Based on this, the priority of the host candidate is 2130706431 and for the server reflexive candidate is 1694498815. The host candidate is assigned a foundation of 1, and the server reflexive, a foundation of 2. These are sent to the peer.  </p>
<p id="rfc.section.13.p.9">This candidate information is received at agent R. Agent R will obtain a host candidate, and from it, obtain a server reflexive candidate (messages 6-7). Since R is not behind a NAT, this candidate is identical to its host candidate, and they share the same base. It therefore discards this redundant candidate and ends up with a single host candidate. With identical type and local preferences as L, the priority for this candidate is 2130706431. It chooses a foundation of 1 for its single candidate. Then R's candidates are then sent to L. </p>
<p id="rfc.section.13.p.10">Since neither side indicated that it is lite, the initiating agent that began ICE processing (agent L) becomes the controlling agent.  </p>
<p id="rfc.section.13.p.11">Agents L and R both pair up the candidates. They both initially have two pairs. However, agent L will prune the pair containing its server reflexive candidate, resulting in just one. At agent L, this pair has a local candidate of $L_PRIV_1 and remote candidate of $R_PUB_1, and has a candidate pair priority of 4.57566E+18 (note that an implementation would represent this as a 64-bit integer so as not to lose precision). At agent R, there are two pairs. The highest priority has a local candidate of $R_PUB_1 and remote candidate of $L_PRIV_1 and has a priority of 4.57566E+18, and the second has a local candidate of $R_PUB_1 and remote candidate of $NAT_PUB_1 and priority 3.63891E+18.  </p>
<p id="rfc.section.13.p.12">Agent R begins its connectivity check (message 9) for the first pair (between the two host candidates). Since R is the controlled agent for this session, the check omits the USE-CANDIDATE attribute. The host candidate from agent L is private and behind a NAT, and thus this check won't be successful, because the packet cannot be routed from R to L.  </p>
<p id="rfc.section.13.p.13">When agent L gets the R's candidates, it performs its one and only connectivity check (messages 10-13). It implements the aggressive nomination algorithm, and thus includes a USE-CANDIDATE attribute in this check. Since the check succeeds, agent L creates a new pair, whose local candidate is from the mapped address in the Binding response (NAT-PUB-1 from message 13) and whose remote candidate is the destination of the request (R-PUB-1 from message 10). This is added to the valid list. In addition, it is marked as selected since the Binding request contained the USE-CANDIDATE attribute. Since there is a selected candidate in the Valid list for the one component of this media stream, ICE processing for this stream moves into the Completed state. Agent L can now send media if it so chooses.  </p>
<p id="rfc.section.13.p.14">Soon after receipt of the STUN Binding request from agent L (message 11), agent R will generate its triggered check. This check happens to match the next one on its check list -- from its host candidate to agent L's server reflexive candidate. This check (messages 14-17) will succeed. Consequently, agent R constructs a new candidate pair using the mapped address from the response as the local candidate (R-PUB-1) and the destination of the request (NAT-PUB-1) as the remote candidate. This pair is added to the Valid list for that media stream. Since the check was generated in the reverse direction of a check that contained the USE-CANDIDATE attribute, the candidate pair is marked as selected. Consequently, processing for this stream moves into the Completed state, and agent R can also send media.  </p>
<h1 id="rfc.section.14"><a href="#rfc.section.14">14.</a> <a href="#sec-security" id="sec-security">Security Considerations</a></h1>
<p id="rfc.section.14.p.1">There are several types of attacks possible in an ICE system. This section considers these attacks and their countermeasures. These countermeasures include: </p>

<ul>
  <li>Using ICE in conjunction with secure signaling techniques, such as SIPS.</li>
  <li>Limiting the total number of connectivity checks to 100, and optionally limiting the number of candidates they'll accept in an candidate exchange.</li>
</ul>

<p> </p>
<h1 id="rfc.section.14.1"><a href="#rfc.section.14.1">14.1.</a> Attacks on Connectivity Checks</h1>
<p id="rfc.section.14.1.p.1">An attacker might attempt to disrupt the STUN connectivity checks. Ultimately, all of these attacks fool an agent into thinking something incorrect about the results of the connectivity checks. The possible false conclusions an attacker can try and cause are: </p>
<p/>

<dl>
  <dt>False Invalid:</dt>
  <dd style="margin-left: 8">An attacker can fool a pair of agents into thinking a candidate pair is invalid, when it isn't. This can be used to cause an agent to prefer a different candidate (such as one injected by the attacker) or to disrupt a call by forcing all candidates to fail.  </dd>
  <dt>False Valid:</dt>
  <dd style="margin-left: 8">An attacker can fool a pair of agents into thinking a candidate pair is valid, when it isn't. This can cause an agent to proceed with a session, but then not be able to receive any media.  </dd>
  <dt>False Peer Reflexive Candidate:</dt>
  <dd style="margin-left: 8">An attacker can cause an agent to discover a new peer reflexive candidate, when it shouldn't have. This can be used to redirect media streams to a Denial-of-Service (DoS) target or to the attacker, for eavesdropping or other purposes.  </dd>
  <dt>False Valid on False Candidate:</dt>
  <dd style="margin-left: 8">An attacker has already convinced an agent that there is a candidate with an address that doesn't actually route to that agent (for example, by injecting a false peer reflexive candidate or false server reflexive candidate). It must then launch an attack that forces the agents to believe that this candidate is valid.  </dd>
  <dt></dt>
  <dd style="margin-left: 8">If an attacker can cause a false peer reflexive candidate or false valid on a false candidate, it can launch any of the attacks described in <a href="#RFC5389">[RFC5389]</a>.  </dd>
</dl>
<p id="rfc.section.14.1.p.3">To force the false invalid result, the attacker has to wait for the connectivity check from one of the agents to be sent. When it is, the attacker needs to inject a fake response with an unrecoverable error response, such as a 400. However, since the candidate is, in fact, valid, the original request may reach the peer agent, and result in a success response. The attacker needs to force this packet or its response to be dropped, through a DoS attack, layer 2 network disruption, or other technique. If it doesn't do this, the success response will also reach the originator, alerting it to a possible attack. Fortunately, this attack is mitigated completely through the STUN short-term credential mechanism. The attacker needs to inject a fake response, and in order for this response to be processed, the attacker needs the password. If the candidate exchange signaling is secured, the attacker will not have the password and its response will be discarded.  </p>
<p id="rfc.section.14.1.p.4">Forcing the fake valid result works in a similar way. The agent needs to wait for the Binding request from each agent, and inject a fake success response. The attacker won't need to worry about disrupting the actual response since, if the candidate is not valid, it presumably wouldn't be received anyway. However, like the fake invalid attack, this attack is mitigated by the STUN short-term credential mechanism in conjunction with a secure candidate exchange.  </p>
<p id="rfc.section.14.1.p.5">Forcing the false peer reflexive candidate result can be done either with fake requests or responses, or with replays. We consider the fake requests and responses case first. It requires the attacker to send a Binding request to one agent with a source IP address and port for the false candidate. In addition, the attacker must wait for a Binding request from the other agent, and generate a fake response with a XOR-MAPPED-ADDRESS attribute containing the false candidate. Like the other attacks described here, this attack is mitigated by the STUN message integrity mechanisms and secure candidate exchanges.  </p>
<p id="rfc.section.14.1.p.6">Forcing the false peer reflexive candidate result with packet replays is different. The attacker waits until one of the agents sends a check. It intercepts this request, and replays it towards the other agent with a faked source IP address. It must also prevent the original request from reaching the remote agent, either by launching a DoS attack to cause the packet to be dropped, or forcing it to be dropped using layer 2 mechanisms. The replayed packet is received at the other agent, and accepted, since the integrity check passes (the integrity check cannot and does not cover the source IP address and port). It is then responded to. This response will contain a XOR-MAPPED-ADDRESS with the false candidate, and will be sent to that false candidate.  The attacker must then receive it and relay it towards the originator.  </p>
<p id="rfc.section.14.1.p.7">The other agent will then initiate a connectivity check towards that false candidate. This validation needs to succeed. This requires the attacker to force a false valid on a false candidate. Injecting of fake requests or responses to achieve this goal is prevented using the integrity mechanisms of STUN and the candidate exchange. Thus, this attack can only be launched through replays. To do that, the attacker must intercept the check towards this false candidate, and replay it towards the other agent. Then, it must intercept the response and replay that back as well.  </p>
<p id="rfc.section.14.1.p.8">This attack is very hard to launch unless the attacker is identified by the fake candidate. This is because it requires the attacker to intercept and replay packets sent by two different hosts. If both agents are on different networks (for example, across the public Internet), this attack can be hard to coordinate, since it needs to occur against two different endpoints on different parts of the network at the same time.  </p>
<p id="rfc.section.14.1.p.9">If the attacker itself is identified by the fake candidate, the attack is easier to coordinate. However, if the media path is secured (e.g., using SRTP <a href="#RFC3711">[RFC3711]</a>), the attacker will not be able to play the media packets, but will only be able to discard them, effectively disabling the media stream for the call. However, this attack requires the agent to disrupt packets in order to block the connectivity check from reaching the target. In that case, if the goal is to disrupt the media stream, it's much easier to just disrupt it with the same mechanism, rather than attack ICE.  </p>
<h1 id="rfc.section.14.2"><a href="#rfc.section.14.2">14.2.</a> Attacks on Server Reflexive Address Gathering</h1>
<p id="rfc.section.14.2.p.1">ICE endpoints make use of STUN Binding requests for gathering server reflexive candidates from a STUN server. These requests are not authenticated in any way. As a consequence, there are numerous techniques an attacker can employ to provide the client with a false server reflexive candidate: </p>

<ul>
  <li>An attacker can compromise the DNS, causing DNS queries to return a rogue STUN server address. That server can provide the client with fake server reflexive candidates. This attack is mitigated by DNS security, though DNS-SEC is not required to address it.  </li>
  <li>An attacker that can observe STUN messages (such as an attacker on a shared network segment, like WiFi) can inject a fake response that is valid and will be accepted by the client.  </li>
  <li>An attacker can compromise a STUN server by means of a virus, and cause it to send responses with incorrect mapped addresses.  </li>
</ul>

<p> </p>
<p id="rfc.section.14.2.p.2">A false mapped address learned by these attacks will be used as a server reflexive candidate in the ICE exchange. For this candidate to actually be used for media, the attacker must also attack the connectivity checks, and in particular, force a false valid on a false candidate. This attack is very hard to launch if the false address identifies a fourth party (neither the initiator, responder, nor attacker), since it requires attacking the checks generated by each agent in the session, and is prevented by SRTP if it identifies the attacker themself.  </p>
<p id="rfc.section.14.2.p.3">If the attacker elects not to attack the connectivity checks, the worst it can do is prevent the server reflexive candidate from being used. However, if the peer agent has at least one candidate that is reachable by the agent under attack, the STUN connectivity checks themselves will provide a peer reflexive candidate that can be used for the exchange of media. Peer reflexive candidates are generally preferred over server reflexive candidates. As such, an attack solely on the STUN address gathering will normally have no impact on a session at all.  </p>
<h1 id="rfc.section.14.3"><a href="#rfc.section.14.3">14.3.</a> Attacks on Relayed Candidate Gathering</h1>
<p id="rfc.section.14.3.p.1">An attacker might attempt to disrupt the gathering of relayed candidates, forcing the client to believe it has a false relayed candidate. Exchanges with the TURN server are authenticated using a long-term credential. Consequently, injection of fake responses or requests will not work. In addition, unlike Binding requests, Allocate requests are not susceptible to replay attacks with modified source IP addresses and ports, since the source IP address and port are not utilized to provide the client with its relayed candidate.  </p>
<p id="rfc.section.14.3.p.2">However, TURN servers are susceptible to DNS attacks, or to viruses aimed at the TURN server, for purposes of turning it into a zombie or rogue server. These attacks can be mitigated by DNS-SEC and through good box and software security on TURN servers.  </p>
<p id="rfc.section.14.3.p.3">Even if an attacker has caused the client to believe in a false relayed candidate, the connectivity checks cause such a candidate to be used only if they succeed. Thus, an attacker must launch a false valid on a false candidate, per above, which is a very difficult attack to coordinate.  </p>
<h1 id="rfc.section.14.4"><a href="#rfc.section.14.4">14.4.</a> Insider Attacks</h1>
<p id="rfc.section.14.4.p.1">In addition to attacks where the attacker is a third party trying to insert fake candidate information or stun messages, there are attacks possible with ICE when the attacker is an authenticated and valid participant in the ICE exchange.  </p>
<h1 id="rfc.section.14.4.1"><a href="#rfc.section.14.4.1">14.4.1.</a> <a href="#sec-ice-hammer" id="sec-ice-hammer">STUN Amplification Attack</a></h1>
<p id="rfc.section.14.4.1.p.1">The STUN amplification attack is similar to the voice hammer. However, instead of voice packets being directed to the target, STUN connectivity checks are directed to the target. The attacker sends an a large number of candidates, say, 50. The responding agent receives the candidate information, and starts its checks, which are directed at the target, and consequently, never generate a response. The answerer will start a new connectivity check every Ta ms (say, Ta=20ms). However, the retransmission timers are set to a large number due to the large number of candidates. As a consequence, packets will be sent at an interval of one every Ta milliseconds, and then with increasing intervals after that. Thus, STUN will not send packets at a rate faster than media would be sent, and the STUN packets persist only briefly, until ICE fails for the session. Nonetheless, this is an amplification mechanism.  </p>
<p id="rfc.section.14.4.1.p.2">It is impossible to eliminate the amplification, but the volume can be reduced through a variety of heuristics. Agents SHOULD limit the total number of connectivity checks they perform to 100. Additionally, agents MAY limit the number of candidates they'll accept.  </p>
<p id="rfc.section.14.4.1.p.3">Frequently, protocols that wish to avoid these kinds of attacks force the initiator to wait for a response prior to sending the next message. However, in the case of ICE, this is not possible. It is not possible to differentiate the following two cases: </p>

<ul>
  <li>There was no response because the initiator is being used to launch a DoS attack against an unsuspecting target that will not respond.  </li>
  <li>There was no response because the IP address and port are not reachable by the initiator.  </li>
</ul>

<p> In the second case, another check should be sent at the next opportunity, while in the former case, no further checks should be sent.  </p>
<h1 id="rfc.section.15"><a href="#rfc.section.15">15.</a> STUN Extensions</h1>
<h1 id="rfc.section.15.1"><a href="#rfc.section.15.1">15.1.</a> <a href="#sec-ice-newatts" id="sec-ice-newatts">New Attributes</a></h1>
<p id="rfc.section.15.1.p.1">This specification defines four new attributes, PRIORITY, USE-CANDIDATE, ICE-CONTROLLED, and ICE-CONTROLLING.  </p>
<p id="rfc.section.15.1.p.2">The PRIORITY attribute indicates the priority that is to be associated with a peer reflexive candidate, should one be discovered by this check. It is a 32-bit unsigned integer, and has an attribute value of 0x0024.  </p>
<p id="rfc.section.15.1.p.3">The USE-CANDIDATE attribute indicates that the candidate pair resulting from this check should be used for transmission of media. The attribute has no content (the Length field of the attribute is zero); it serves as a flag. It has an attribute value of 0x0025.  </p>
<p id="rfc.section.15.1.p.4">The ICE-CONTROLLED attribute is present in a Binding request and indicates that the client believes it is currently in the controlled role. The content of the attribute is a 64-bit unsigned integer in network byte order, which contains a random number used for tie-breaking of role conflicts.  </p>
<p id="rfc.section.15.1.p.5">The ICE-CONTROLLING attribute is present in a Binding request and indicates that the client believes it is currently in the controlling role. The content of the attribute is a 64-bit unsigned integer in network byte order, which contains a random number used for tie-breaking of role conflicts.  </p>
<h1 id="rfc.section.15.2"><a href="#rfc.section.15.2">15.2.</a> New Error Response Codes</h1>
<p id="rfc.section.15.2.p.1">This specification defines a single error response code:</p>
<p/>

<dl>
  <dt>487 (Role Conflict):</dt>
  <dd style="margin-left: 8">The Binding request contained either the ICE-CONTROLLING or ICE-CONTROLLED attribute, indicating a role that conflicted with the server. The server ran a tie-breaker based on the tie-breaker value in the request and determined that the client needs to switch roles.  </dd>
</dl>
<h1 id="rfc.section.16"><a href="#rfc.section.16">16.</a> Operational Considerations</h1>
<p id="rfc.section.16.p.1">This section discusses issues relevant to network operators looking to deploy ICE.  </p>
<h1 id="rfc.section.16.1"><a href="#rfc.section.16.1">16.1.</a> NAT and Firewall Types</h1>
<p id="rfc.section.16.1.p.1">ICE was designed to work with existing NAT and firewall equipment. Consequently, it is not necessary to replace or reconfigure existing firewall and NAT equipment in order to facilitate deployment of ICE. Indeed, ICE was developed to be deployed in environments where the Voice over IP (VoIP) operator has no control over the IP network infrastructure, including firewalls and NAT.  </p>
<p id="rfc.section.16.1.p.2">That said, ICE works best in environments where the NAT devices are "behave" compliant, meeting the recommendations defined in <a href="#RFC4787">[RFC4787]</a> and <a href="#RFC5382">[RFC5382]</a>. In networks with behave-compliant NAT, ICE will work without the need for a TURN server, thus improving voice quality, decreasing call setup times, and reducing the bandwidth demands on the network operator.  </p>
<h1 id="rfc.section.16.2"><a href="#rfc.section.16.2">16.2.</a> Bandwidth Requirements</h1>
<p id="rfc.section.16.2.p.1">Deployment of ICE can have several interactions with available network capacity that operators should take into consideration.  </p>
<h1 id="rfc.section.16.2.1"><a href="#rfc.section.16.2.1">16.2.1.</a> STUN and TURN Server Capacity Planning</h1>
<p id="rfc.section.16.2.1.p.1">First and foremost, ICE makes use of TURN and STUN servers, which would typically be located in the network operator's data centers. The STUN servers require relatively little bandwidth. For each component of each media stream, there will be one or more STUN transactions from each client to the STUN server. In a basic voice-only IPv4 VoIP deployment, there will be four transactions per call (one for RTP and one for RTCP, for both caller and callee). Each transaction is a single request and a single response, the former being 20 bytes long, and the latter, 28. Consequently, if a system has N users, and each makes four calls in a busy hour, this would require N*1.7bps. For one million users, this is 1.7 Mbps, a very small number (relatively speaking).  </p>
<p id="rfc.section.16.2.1.p.2">TURN traffic is more substantial. The TURN server will see traffic volume equal to the STUN volume (indeed, if TURN servers are deployed, there is no need for a separate STUN server), in addition to the traffic for the actual media traffic. The amount of calls requiring TURN for media relay is highly dependent on network topologies, and can and will vary over time. In a network with 100% behave-compliant NAT, it is exactly zero. At time of writing, large-scale consumer deployments were seeing between 5 and 10 percent of calls requiring TURN servers. Considering a voice-only deployment using G.711 (so 80 kbps in each direction), with .2 erlangs during the busy hour, this is N*3.2 kbps. For a population of one million users, this is 3.2 Gbps, assuming a 10% usage of TURN servers.  </p>
<h1 id="rfc.section.16.2.2"><a href="#rfc.section.16.2.2">16.2.2.</a> Gathering and Connectivity Checks</h1>
<p id="rfc.section.16.2.2.p.1">The process of gathering of candidates and performing of connectivity checks can be bandwidth intensive. ICE has been designed to pace both of these processes. The gathering phase and the connectivity check phase are meant to generate traffic at roughly the same bandwidth as the media traffic itself. This was done to ensure that, if a network is designed to support multimedia traffic of a certain type (voice, video, or just text), it will have sufficient capacity to support the ICE checks for that media. Of course, the ICE checks will cause a marginal increase in the total utilization; however, this will typically be an extremely small increase.  </p>
<p id="rfc.section.16.2.2.p.2">Congestion due to the gathering and check phases has proven to be a problem in deployments that did not utilize pacing. Typically, access links became congested as the endpoints flooded the network with checks as fast as they can send them. Consequently, network operators should make sure that their ICE implementations support the pacing feature. Though this pacing does increase call setup times, it makes ICE network friendly and easier to deploy.  </p>
<h1 id="rfc.section.16.2.3"><a href="#rfc.section.16.2.3">16.2.3.</a> Keepalives</h1>
<p id="rfc.section.16.2.3.p.1">STUN keepalives (in the form of STUN Binding Indications) are sent in the middle of a media session. However, they are sent only in the absence of actual media traffic. In deployments that are not utilizing Voice Activity Detection (VAD), the keepalives are never used and there is no increase in bandwidth usage. When VAD is being used, keepalives will be sent during silence periods. This involves a single packet every 15-20 seconds, far less than the packet every 20-30 ms that is sent when there is voice. Therefore, keepalives don't have any real impact on capacity planning.  </p>
<h1 id="rfc.section.16.3"><a href="#rfc.section.16.3">16.3.</a> ICE and ICE-lite</h1>
<p id="rfc.section.16.3.p.1">Deployments utilizing a mix of ICE and ICE-lite interoperate perfectly. They have been explicitly designed to do so, without loss of function.  </p>
<p id="rfc.section.16.3.p.2">However, ICE-lite can only be deployed in limited use cases. Those cases, and the caveats involved in doing so, are documented in <a href="#sec-liteandfull">Appendix A</a>.  </p>
<h1 id="rfc.section.16.4"><a href="#rfc.section.16.4">16.4.</a> Troubleshooting and Performance Management</h1>
<p id="rfc.section.16.4.p.1">ICE utilizes end-to-end connectivity checks, and places much of the processing in the endpoints. This introduces a challenge to the network operator -- how can they troubleshoot ICE deployments? How can they know how ICE is performing? </p>
<p id="rfc.section.16.4.p.2">ICE has built-in features to help deal with these problems. SIP servers on the signaling path, typically deployed in the data centers of the network operator, will see the contents of the candidate exchanges that convey the ICE parameters. These parameters include the type of each candidate (host, server reflexive, or relayed), along with their related addresses. Once ICE processing has completed, an updated candidate exchange takes place, signaling the selected address (and its type). This updated re-INVITE is performed exactly for the purposes of educating network equipment (such as a diagnostic tool attached to a SIP server) about the results of ICE processing.  </p>
<p id="rfc.section.16.4.p.3">As a consequence, through the logs generated by the SIP server, a network operator can observe what types of candidates are being used for each call, and what address was selected by ICE. This is the primary information that helps evaluate how ICE is performing.  </p>
<h1 id="rfc.section.16.5"><a href="#rfc.section.16.5">16.5.</a> Endpoint Configuration</h1>
<p id="rfc.section.16.5.p.1">ICE relies on several pieces of data being configured into the endpoints. This configuration data includes timers, credentials for TURN servers, and hostnames for STUN and TURN servers. ICE itself does not provide a mechanism for this configuration. Instead, it is assumed that this information is attached to whatever mechanism is used to configure all of the other parameters in the endpoint. For SIP phones, standard solutions such as the configuration framework <a href="#RFC6080">[RFC6080]</a> have been defined.  </p>
<h1 id="rfc.section.17"><a href="#rfc.section.17">17.</a> IANA Considerations</h1>
<p id="rfc.section.17.p.1">The original ICE specification registered four new STUN attributes, and one new STUN error response. The STUN attributes and error response are reproduced here.  </p>
<h1 id="rfc.section.17.1"><a href="#rfc.section.17.1">17.1.</a> STUN Attributes</h1>
<p id="rfc.section.17.1.p.1">IANA has registered four STUN attributes: </p>
<pre>

   0x0024 PRIORITY
   0x0025 USE-CANDIDATE
   0x8029 ICE-CONTROLLED
   0x802A ICE-CONTROLLING
</pre>
<h1 id="rfc.section.17.2"><a href="#rfc.section.17.2">17.2.</a> STUN Error Responses</h1>
<p id="rfc.section.17.2.p.1">IANA has registered following STUN error response code: </p>
<pre>

 487   Role Conflict: The client asserted an ICE role (controlling or
       controlled) that is in conflict with the role of the server.
</pre>
<h1 id="rfc.section.18"><a href="#rfc.section.18">18.</a> <a href="#sec-iab" id="sec-iab">IAB Considerations</a></h1>
<p id="rfc.section.18.p.1">The IAB has studied the problem of "Unilateral Self-Address Fixing", which is the general process by which a agent attempts to determine its address in another realm on the other side of a NAT through a collaborative protocol reflection mechanism <a href="#RFC3424">[RFC3424]</a>.  ICE is an example of a protocol that performs this type of function. Interestingly, the process for ICE is not unilateral, but bilateral, and the difference has a significant impact on the issues raised by IAB. Indeed, ICE can be considered a B-SAF (Bilateral Self-Address Fixing) protocol, rather than an UNSAF protocol. Regardless, the IAB has mandated that any protocols developed for this purpose document a specific set of considerations. This section meets those requirements.  </p>
<h1 id="rfc.section.18.1"><a href="#rfc.section.18.1">18.1.</a> Problem Definition</h1>
<p id="rfc.section.18.1.p.1">&gt;From RFC 3424, any UNSAF proposal must provide: </p>
<p/>

<dl>
  <dt></dt>
  <dd style="margin-left: 8">Precise definition of a specific, limited-scope problem that is to be solved with the UNSAF proposal.  A short-term fix should not be generalized to solve other problems; this is why "short-term fixes usually aren't".  </dd>
</dl>
<p id="rfc.section.18.1.p.3">The specific problems being solved by ICE are: </p>
<p/>

<dl>
  <dt></dt>
  <dd style="margin-left: 8">Provide a means for two peers to determine the set of transport addresses that can be used for communication.  </dd>
  <dt></dt>
  <dd style="margin-left: 8">Provide a means for a agent to determine an address that is reachable by another peer with which it wishes to communicate.  </dd>
</dl>
<h1 id="rfc.section.18.2"><a href="#rfc.section.18.2">18.2.</a> Exit Strategy</h1>
<p id="rfc.section.18.2.p.1">&gt;From RFC 3424, any UNSAF proposal must provide: </p>
<p/>

<dl>
  <dt></dt>
  <dd style="margin-left: 8">Description of an exit strategy/transition plan.  The better short-term fixes are the ones that will naturally see less and less use as the appropriate technology is deployed.  </dd>
</dl>
<p id="rfc.section.18.2.p.3">ICE itself doesn't easily get phased out. However, it is useful even in a globally connected Internet, to serve as a means for detecting whether a router failure has temporarily disrupted connectivity, for example. ICE also helps prevent certain security attacks that have nothing to do with NAT. However, what ICE does is help phase out other UNSAF mechanisms. ICE effectively selects amongst those mechanisms, prioritizing ones that are better, and deprioritizing ones that are worse. Local IPv6 addresses can be preferred. As NATs begin to dissipate as IPv6 is introduced, server reflexive and relayed candidates (both forms of UNSAF addresses) simply never get used, because higher-priority connectivity exists to the native host candidates. Therefore, the servers get used less and less, and can eventually be remove when their usage goes to zero.  </p>
<p id="rfc.section.18.2.p.4">Indeed, ICE can assist in the transition from IPv4 to IPv6. It can be used to determine whether to use IPv6 or IPv4 when two dual-stack hosts communicate with SIP (IPv6 gets used). It can also allow a network with both 6to4 and native v6 connectivity to determine which address to use when communicating with a peer.  </p>
<h1 id="rfc.section.18.3"><a href="#rfc.section.18.3">18.3.</a> Brittleness Introduced by ICE</h1>
<p id="rfc.section.18.3.p.1">&gt;From RFC 3424, any UNSAF proposal must provide: </p>
<p/>

<dl>
  <dt></dt>
  <dd style="margin-left: 8">Discussion of specific issues that may render systems more "brittle".  For example, approaches that involve using data at multiple network layers create more dependencies, increase debugging challenges, and make it harder to transition.  </dd>
</dl>
<p id="rfc.section.18.3.p.3">ICE actually removes brittleness from existing UNSAF mechanisms. In particular, classic STUN (as described in RFC 3489 <a href="#RFC3489">[RFC3489]</a>) has several points of brittleness. One of them is the discovery process that requires an agent to try to classify the type of NAT it is behind. This process is error-prone. With ICE, that discovery process is simply not used. Rather than unilaterally assessing the validity of the address, its validity is dynamically determined by measuring connectivity to a peer. The process of determining connectivity is very robust.  </p>
<p id="rfc.section.18.3.p.4">Another point of brittleness in classic STUN and any other unilateral mechanism is its absolute reliance on an additional server. ICE makes use of a server for allocating unilateral addresses, but allows agents to directly connect if possible. Therefore, in some cases, the failure of a STUN server would still allow for a call to progress when ICE is used.  </p>
<p id="rfc.section.18.3.p.5">Another point of brittleness in classic STUN is that it assumes that the STUN server is on the public Internet. Interestingly, with ICE, that is not necessary. There can be a multitude of STUN servers in a variety of address realms. ICE will discover the one that has provided a usable address.  </p>
<p id="rfc.section.18.3.p.6">The most troubling point of brittleness in classic STUN is that it doesn't work in all network topologies. In cases where there is a shared NAT between each agent and the STUN server, traditional STUN may not work. With ICE, that restriction is removed.  </p>
<p id="rfc.section.18.3.p.7">Classic STUN also introduces some security considerations. Fortunately, those security considerations are also mitigated by ICE.  </p>
<p id="rfc.section.18.3.p.8">Consequently, ICE serves to repair the brittleness introduced in classic STUN, and does not introduce any additional brittleness into the system.  </p>
<p id="rfc.section.18.3.p.9">The penalty of these improvements is that ICE increases session establishment times.  </p>
<h1 id="rfc.section.18.4"><a href="#rfc.section.18.4">18.4.</a> Requirements for a Long-Term Solution</h1>
<p id="rfc.section.18.4.p.1">From RFC 3424, any UNSAF proposal must provide: </p>
<p/>

<dl>
  <dt></dt>
  <dd style="margin-left: 8">... requirements for longer term, sound technical solutions -- contribute to the process of finding the right longer term solution.  </dd>
</dl>
<p id="rfc.section.18.4.p.3">Our conclusions from RFC 3489 remain unchanged. However, we feel ICE actually helps because we believe it can be part of the long-term solution.  </p>
<h1 id="rfc.section.18.5"><a href="#rfc.section.18.5">18.5.</a> Issues with Existing NAPT Boxes</h1>
<p id="rfc.section.18.5.p.1">From RFC 3424, any UNSAF proposal must provide: </p>
<p/>

<dl>
  <dt></dt>
  <dd style="margin-left: 8">Discussion of the impact of the noted practical issues with existing, deployed NA[P]Ts and experience reports.  </dd>
</dl>
<p id="rfc.section.18.5.p.3">A number of NAT boxes are now being deployed into the market that try to provide "generic" ALG functionality. These generic ALGs hunt for IP addresses, either in text or binary form within a packet, and rewrite them if they match a binding. This interferes with classic STUN. However, the update to STUN <a href="#RFC5389">[RFC5389]</a> uses an encoding that hides these binary addresses from generic ALGs.  </p>
<p id="rfc.section.18.5.p.4">Existing NAPT boxes have non-deterministic and typically short expiration times for UDP-based bindings. This requires implementations to send periodic keepalives to maintain those bindings. ICE uses a default of 15 s, which is a very conservative estimate. Eventually, over time, as NAT boxes become compliant to behave <a href="#RFC4787">[RFC4787]</a>, this minimum keepalive will become deterministic and well-known, and the ICE timers can be adjusted. Having a way to discover and control the minimum keepalive interval would be far better still.  </p>
<h1 id="rfc.section.19"><a href="#rfc.section.19">19.</a> Changes from RFC 5245</h1>
<p id="rfc.section.19.p.1">Following is the list of changes from RFC 5245 </p>

<ul>
  <li>The specification was generalized to be more usable with any protocol and the parts that are specific to SIP and SDP were moved to a SIP/SDP usage document <a href="#I-D.ietf-mmusic-ice-sip-sdp">[I-D.ietf-mmusic-ice-sip-sdp]</a>. </li>
  <li>Default candidates, multiple components, ICE mismatch detection, subsequent offer/answer, and role conflict resolution were made optional since they are not needed with every protocol using ICE. </li>
  <li>With IPv6, the precedence rules of RFC 6724 are used instead of the obsoleted RFC 3483 and using address preferences provided by the host operating system is recommended. </li>
  <li>Candidate gathering rules regarding loopback addresses and IPv6 addresses were clarified. </li>
</ul>

<p> </p>
<h1 id="rfc.section.20"><a href="#rfc.section.20">20.</a> Acknowledgements</h1>
<p id="rfc.section.20.p.1">Most of the text in this document comes from the original ICE specification, RFC 5245. The authors would like to thank everyone who has contributed to that document. For additional contributions to this revision of the specification we would like to thank Emil Ivov, Paul Kyzivat, Pal-Erik Martinsen, Simon Perrault, Eric Rescorla, Thomas Stach, Peter Thatcher, Martin Thomson, Justin Uberti, and Suhas Nandakumar. </p>
<h1 id="rfc.references"><a href="#rfc.references">21.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">21.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5389">[RFC5389]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a>, <a>Mahy, R.</a>, <a>Matthews, P.</a> and <a>D. Wing</a>, "<a href="http://tools.ietf.org/html/rfc5389">Session Traversal Utilities for NAT (STUN)</a>", RFC 5389, DOI 10.17487/RFC5389, October 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5766">[RFC5766]</b>
      </td>
      <td class="top"><a>Mahy, R.</a>, <a>Matthews, P.</a> and <a>J. Rosenberg</a>, "<a href="http://tools.ietf.org/html/rfc5766">Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)</a>", RFC 5766, DOI 10.17487/RFC5766, April 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6724">[RFC6724]</b>
      </td>
      <td class="top"><a>Thaler, D.</a>, <a>Draves, R.</a>, <a>Matsumoto, A.</a> and <a>T. Chown</a>, "<a href="http://tools.ietf.org/html/rfc6724">Default Address Selection for Internet Protocol Version 6 (IPv6)</a>", RFC 6724, DOI 10.17487/RFC6724, September 2012.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">21.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC3605">[RFC3605]</b>
      </td>
      <td class="top"><a>Huitema, C.</a>, "<a href="http://tools.ietf.org/html/rfc3605">Real Time Control Protocol (RTCP) attribute in Session Description Protocol (SDP)</a>", RFC 3605, DOI 10.17487/RFC3605, October 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3261">[RFC3261]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a>, <a>Schulzrinne, H.</a>, <a>Camarillo, G.</a>, <a>Johnston, A.</a>, <a>Peterson, J.</a>, <a>Sparks, R.</a>, <a>Handley, M.</a> and <a>E. Schooler</a>, "<a href="http://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>", RFC 3261, DOI 10.17487/RFC3261, June 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3264">[RFC3264]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a> and <a>H. Schulzrinne</a>, "<a href="http://tools.ietf.org/html/rfc3264">An Offer/Answer Model with Session Description Protocol (SDP)</a>", RFC 3264, DOI 10.17487/RFC3264, June 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3489">[RFC3489]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a>, <a>Weinberger, J.</a>, <a>Huitema, C.</a> and <a>R. Mahy</a>, "<a href="http://tools.ietf.org/html/rfc3489">STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)</a>", RFC 3489, DOI 10.17487/RFC3489, March 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3235">[RFC3235]</b>
      </td>
      <td class="top"><a>Senie, D.</a>, "<a href="http://tools.ietf.org/html/rfc3235">Network Address Translator (NAT)-Friendly Application Design Guidelines</a>", RFC 3235, DOI 10.17487/RFC3235, January 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3303">[RFC3303]</b>
      </td>
      <td class="top"><a>Srisuresh, P.</a>, <a>Kuthan, J.</a>, <a>Rosenberg, J.</a>, <a>Molitor, A.</a> and <a>A. Rayhan</a>, "<a href="http://tools.ietf.org/html/rfc3303">Middlebox communication architecture and framework</a>", RFC 3303, DOI 10.17487/RFC3303, August 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3102">[RFC3102]</b>
      </td>
      <td class="top"><a>Borella, M.</a>, <a>Lo, J.</a>, <a>Grabelsky, D.</a> and <a>G. Montenegro</a>, "<a href="http://tools.ietf.org/html/rfc3102">Realm Specific IP: Framework</a>", RFC 3102, DOI 10.17487/RFC3102, October 2001.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3103">[RFC3103]</b>
      </td>
      <td class="top"><a>Borella, M.</a>, <a>Grabelsky, D.</a>, <a>Lo, J.</a> and <a>K. Taniguchi</a>, "<a href="http://tools.ietf.org/html/rfc3103">Realm Specific IP: Protocol Specification</a>", RFC 3103, DOI 10.17487/RFC3103, October 2001.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3424">[RFC3424]</b>
      </td>
      <td class="top"><a>Daigle, L.</a> and <a>IAB</a>, "<a href="http://tools.ietf.org/html/rfc3424">IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation</a>", RFC 3424, DOI 10.17487/RFC3424, November 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3550">[RFC3550]</b>
      </td>
      <td class="top"><a>Schulzrinne, H.</a>, <a>Casner, S.</a>, <a>Frederick, R.</a> and <a>V. Jacobson</a>, "<a href="http://tools.ietf.org/html/rfc3550">RTP: A Transport Protocol for Real-Time Applications</a>", STD 64, RFC 3550, DOI 10.17487/RFC3550, July 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3711">[RFC3711]</b>
      </td>
      <td class="top"><a>Baugher, M.</a>, <a>McGrew, D.</a>, <a>Naslund, M.</a>, <a>Carrara, E.</a> and <a>K. Norrman</a>, "<a href="http://tools.ietf.org/html/rfc3711">The Secure Real-time Transport Protocol (SRTP)</a>", RFC 3711, DOI 10.17487/RFC3711, March 2004.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3056">[RFC3056]</b>
      </td>
      <td class="top"><a>Carpenter, B.</a> and <a>K. Moore</a>, "<a href="http://tools.ietf.org/html/rfc3056">Connection of IPv6 Domains via IPv4 Clouds</a>", RFC 3056, DOI 10.17487/RFC3056, February 2001.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3389">[RFC3389]</b>
      </td>
      <td class="top"><a>Zopf, R.</a>, "<a href="http://tools.ietf.org/html/rfc3389">Real-time Transport Protocol (RTP) Payload for Comfort Noise (CN)</a>", RFC 3389, DOI 10.17487/RFC3389, September 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3879">[RFC3879]</b>
      </td>
      <td class="top"><a>Huitema, C.</a> and <a>B. Carpenter</a>, "<a href="http://tools.ietf.org/html/rfc3879">Deprecating Site Local Addresses</a>", RFC 3879, DOI 10.17487/RFC3879, September 2004.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4038">[RFC4038]</b>
      </td>
      <td class="top"><a>Shin, M-K.</a>, <a>Hong, Y-G.</a>, <a>Hagino, J.</a>, <a>Savola, P.</a> and <a>E. Castro</a>, "<a href="http://tools.ietf.org/html/rfc4038">Application Aspects of IPv6 Transition</a>", RFC 4038, DOI 10.17487/RFC4038, March 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4091">[RFC4091]</b>
      </td>
      <td class="top"><a>Camarillo, G.</a> and <a>J. Rosenberg</a>, "<a href="http://tools.ietf.org/html/rfc4091">The Alternative Network Address Types (ANAT) Semantics for the Session Description Protocol (SDP) Grouping Framework</a>", RFC 4091, DOI 10.17487/RFC4091, June 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4092">[RFC4092]</b>
      </td>
      <td class="top"><a>Camarillo, G.</a> and <a>J. Rosenberg</a>, "<a href="http://tools.ietf.org/html/rfc4092">Usage of the Session Description Protocol (SDP) Alternative Network Address Types (ANAT) Semantics in the Session Initiation Protocol (SIP)</a>", RFC 4092, DOI 10.17487/RFC4092, June 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4291">[RFC4291]</b>
      </td>
      <td class="top"><a>Hinden, R.</a> and <a>S. Deering</a>, "<a href="http://tools.ietf.org/html/rfc4291">IP Version 6 Addressing Architecture</a>", RFC 4291, DOI 10.17487/RFC4291, February 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4566">[RFC4566]</b>
      </td>
      <td class="top"><a>Handley, M.</a>, <a>Jacobson, V.</a> and <a>C. Perkins</a>, "<a href="http://tools.ietf.org/html/rfc4566">SDP: Session Description Protocol</a>", RFC 4566, DOI 10.17487/RFC4566, July 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2475">[RFC2475]</b>
      </td>
      <td class="top"><a>Blake, S.</a>, <a>Black, D.</a>, <a>Carlson, M.</a>, <a>Davies, E.</a>, <a>Wang, Z.</a> and <a>W. Weiss</a>, "<a href="http://tools.ietf.org/html/rfc2475">An Architecture for Differentiated Services</a>", RFC 2475, DOI 10.17487/RFC2475, December 1998.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC1918">[RFC1918]</b>
      </td>
      <td class="top"><a>Rekhter, Y.</a>, <a>Moskowitz, B.</a>, <a>Karrenberg, D.</a>, <a>de Groot, G.</a> and <a>E. Lear</a>, "<a href="http://tools.ietf.org/html/rfc1918">Address Allocation for Private Internets</a>", BCP 5, RFC 1918, DOI 10.17487/RFC1918, February 1996.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4787">[RFC4787]</b>
      </td>
      <td class="top"><a>Audet, F.</a> and <a>C. Jennings</a>, "<a href="http://tools.ietf.org/html/rfc4787">Network Address Translation (NAT) Behavioral Requirements for Unicast UDP</a>", BCP 127, RFC 4787, DOI 10.17487/RFC4787, January 2007.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-avt-rtp-no-op">[I-D.ietf-avt-rtp-no-op]</b>
      </td>
      <td class="top"><a>Andreasen, F.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-avt-rtp-no-op-04">A No-Op Payload Format for RTP</a>", Internet-Draft draft-ietf-avt-rtp-no-op-04, May 2007.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5761">[RFC5761]</b>
      </td>
      <td class="top"><a>Perkins, C.</a> and <a>M. Westerlund</a>, "<a href="http://tools.ietf.org/html/rfc5761">Multiplexing RTP Data and Control Packets on a Single Port</a>", RFC 5761, DOI 10.17487/RFC5761, April 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4103">[RFC4103]</b>
      </td>
      <td class="top"><a>Hellstrom, G.</a> and <a>P. Jones</a>, "<a href="http://tools.ietf.org/html/rfc4103">RTP Payload for Text Conversation</a>", RFC 4103, DOI 10.17487/RFC4103, June 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5245">[RFC5245]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a>, "<a href="http://tools.ietf.org/html/rfc5245">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</a>", RFC 5245, DOI 10.17487/RFC5245, April 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5382">[RFC5382]</b>
      </td>
      <td class="top"><a>Guha, S.</a>, <a>Biswas, K.</a>, <a>Ford, B.</a>, <a>Sivakumar, S.</a> and <a>P. Srisuresh</a>, "<a href="http://tools.ietf.org/html/rfc5382">NAT Behavioral Requirements for TCP</a>", BCP 142, RFC 5382, DOI 10.17487/RFC5382, October 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6080">[RFC6080]</b>
      </td>
      <td class="top"><a>Petrie, D.</a> and <a>S. Channabasappa</a>, "<a href="http://tools.ietf.org/html/rfc6080">A Framework for Session Initiation Protocol User Agent Profile Delivery</a>", RFC 6080, DOI 10.17487/RFC6080, March 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6146">[RFC6146]</b>
      </td>
      <td class="top"><a>Bagnulo, M.</a>, <a>Matthews, P.</a> and <a>I. van Beijnum</a>, "<a href="http://tools.ietf.org/html/rfc6146">Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers</a>", RFC 6146, DOI 10.17487/RFC6146, April 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6147">[RFC6147]</b>
      </td>
      <td class="top"><a>Bagnulo, M.</a>, <a>Sullivan, A.</a>, <a>Matthews, P.</a> and <a>I. van Beijnum</a>, "<a href="http://tools.ietf.org/html/rfc6147">DNS64: DNS Extensions for Network Address Translation from IPv6 Clients to IPv4 Servers</a>", RFC 6147, DOI 10.17487/RFC6147, April 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6544">[RFC6544]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a>, <a>Keranen, A.</a>, <a>Lowekamp, B.</a> and <a>A. Roach</a>, "<a href="http://tools.ietf.org/html/rfc6544">TCP Candidates with Interactive Connectivity Establishment (ICE)</a>", RFC 6544, DOI 10.17487/RFC6544, March 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7050">[RFC7050]</b>
      </td>
      <td class="top"><a>Savolainen, T.</a>, <a>Korhonen, J.</a> and <a>D. Wing</a>, "<a href="http://tools.ietf.org/html/rfc7050">Discovery of the IPv6 Prefix Used for IPv6 Address Synthesis</a>", RFC 7050, DOI 10.17487/RFC7050, November 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-mmusic-ice-sip-sdp">[I-D.ietf-mmusic-ice-sip-sdp]</b>
      </td>
      <td class="top"><a>Petit-Huguenin, M.</a>, <a>Keranen, A.</a> and <a>S. Nandakumar</a>, "<a href="http://tools.ietf.org/html/draft-ietf-mmusic-ice-sip-sdp-07">Using Interactive Connectivity Establishment (ICE) with Session Description Protocol (SDP) offer/answer and Session Initiation Protocol (SIP)</a>", Internet-Draft draft-ietf-mmusic-ice-sip-sdp-07, October 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-6man-ipv6-address-generation-privacy">[I-D.ietf-6man-ipv6-address-generation-privacy]</b>
      </td>
      <td class="top"><a>Cooper, A.</a>, <a>Gont, F.</a> and <a>D. Thaler</a>, "<a href="http://tools.ietf.org/html/draft-ietf-6man-ipv6-address-generation-privacy-08">Privacy Considerations for IPv6 Address Generation Mechanisms</a>", Internet-Draft draft-ietf-6man-ipv6-address-generation-privacy-08, September 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#sec-liteandfull" id="sec-liteandfull">Lite and Full Implementations</a></h1>
<p id="rfc.section.A.p.1">ICE allows for two types of implementations. A full implementation supports the controlling and controlled roles in a session, and can also perform address gathering. In contrast, a lite implementation is a minimalist implementation that does little but respond to STUN checks.  </p>
<p id="rfc.section.A.p.2">Because ICE requires both endpoints to support it in order to bring benefits to either endpoint, incremental deployment of ICE in a network is more complicated. Many sessions involve an endpoint that is, by itself, not behind a NAT and not one that would worry about NAT traversal. A very common case is to have one endpoint that requires NAT traversal (such as a VoIP hard phone or soft phone) make a call to one of these devices. Even if the phone supports a full ICE implementation, ICE won't be used at all if the other device doesn't support it. The lite implementation allows for a low-cost entry point for these devices. Once they support the lite implementation, full implementations can connect to them and get the full benefits of ICE.  </p>
<p id="rfc.section.A.p.3">Consequently, a lite implementation is only appropriate for devices that will *always* be connected to the public Internet and have a public IP address at which it can receive packets from any correspondent. ICE will not function when a lite implementation is placed behind a NAT.  </p>
<p id="rfc.section.A.p.4">ICE allows a lite implementation to have a single IPv4 host candidate and several IPv6 addresses. In that case, candidate pairs are selected by the controlling agent using a static algorithm, such as the one in RFC 6724, which is recommended by this specification. However, static mechanisms for address selection are always prone to error, since they cannot ever reflect the actual topology and can never provide actual guarantees on connectivity. They are always heuristics. Consequently, if an agent is implementing ICE just to select between its IPv4 and IPv6 addresses, and none of its IP addresses are behind NAT, usage of full ICE is still RECOMMENDED in order to provide the most robust form of address selection possible.  </p>
<p id="rfc.section.A.p.5">It is important to note that the lite implementation was added to this specification to provide a stepping stone to full implementation. Even for devices that are always connected to the public Internet with just a single IPv4 address, a full implementation is preferable if achievable. A full implementation will reduce call setup times, since ICE's aggressive mode can be used. Full implementations also obtain the security benefits of ICE unrelated to NAT traversal; in particular, the voice hammer attack described in <a href="#sec-security">Section 14</a> is prevented only for full implementations, not lite. Finally, it is often the case that a device that finds itself with a public address today will be placed in a network tomorrow where it will be behind a NAT. It is difficult to definitively know, over the lifetime of a device or product, that it will always be used on the public Internet. Full implementation provides assurance that communications will always work.  </p>
<h1 id="rfc.appendix.B"><a href="#rfc.appendix.B">Appendix B.</a> Design Motivations</h1>
<p id="rfc.section.B.p.1">ICE contains a number of normative behaviors that may themselves be simple, but derive from complicated or non-obvious thinking or use cases that merit further discussion. Since these design motivations are not necessary to understand for purposes of implementation, they are discussed here in an appendix to the specification. This section is non-normative.  </p>
<h1 id="rfc.appendix.B.1"><a href="#rfc.appendix.B.1">B.1.</a> <a href="#sec-pacing" id="sec-pacing">Pacing of STUN Transactions</a></h1>
<p id="rfc.section.B.1.p.1">STUN transactions used to gather candidates and to verify connectivity are paced out at an approximate rate of one new transaction every Ta milliseconds. Each transaction, in turn, has a retransmission timer RTO that is a function of Ta as well. Why are these transactions paced, and why are these formulas used? </p>
<p id="rfc.section.B.1.p.2">Sending of these STUN requests will often have the effect of creating bindings on NAT devices between the client and the STUN servers. Experience has shown that many NAT devices have upper limits on the rate at which they will create new bindings. Experiments have shown that once every 20 ms is well supported, but not much lower than that. This is why Ta has a lower bound of 20 ms. Furthermore, transmission of these packets on the network makes use of bandwidth and needs to be rate limited by the agent. Deployments based on earlier draft versions of <a href="#RFC5245">[RFC5245]</a> tended to overload rate-constrained access links and perform poorly overall, in addition to negatively impacting the network. As a consequence, the pacing ensures that the NAT device does not get overloaded and that traffic is kept at a reasonable rate.  </p>
<p id="rfc.section.B.1.p.3">The definition of a "reasonable" rate is that STUN should not use more bandwidth than the RTP itself will use, once media starts flowing. The formula for Ta is designed so that, if a STUN packet were sent every Ta seconds, it would consume the same amount of bandwidth as RTP packets, summed across all media streams. Of course, STUN has retransmits, and the desire is to pace those as well. For this reason, RTO is set such that the first retransmit on the first transaction happens just as the first STUN request on the last transaction occurs. Pictorially: </p>
<pre>


           First Packets              Retransmits



                 |                        |
                 |                        |
          -------+------           -------+------
         /               \        /               \
        /                 \      /                 \

        +--+    +--+    +--+    +--+    +--+    +--+
        |A1|    |B1|    |C1|    |A2|    |B2|    |C2|
        +--+    +--+    +--+    +--+    +--+    +--+

     ---+-------+-------+-------+-------+-------+------------ Time
        0       Ta      2Ta     3Ta     4Ta     5Ta
</pre>
<p id="rfc.section.B.1.p.4">In this picture, there are three transactions that will be sent (for example, in the case of candidate gathering, there are three host candidate/STUN server pairs). These are transactions A, B, and C. The retransmit timer is set so that the first retransmission on the first transaction (packet A2) is sent at time 3Ta.  </p>
<p id="rfc.section.B.1.p.5">Subsequent retransmits after the first will occur even less frequently than Ta milliseconds apart, since STUN uses an exponential back-off on its retransmissions.  </p>
<h1 id="rfc.appendix.B.2"><a href="#rfc.appendix.B.2">B.2.</a> Candidates with Multiple Bases</h1>
<p><a href="#sec-el-red">Section 4.1.3</a> talks about eliminating candidates that have the same transport address and base. However, candidates with the same transport addresses but different bases are not redundant. When can an agent have two candidates that have the same IP address and port, but different bases? Consider the topology of <a href="#fig-horror-net">Figure 11</a>: </p>
<div id="rfc.figure.11"/>
<div id="fig-horror-net"/>
<pre>


       +----------+
       | STUN Srvr|
       +----------+
            |
            |
          -----
        //     \\
       |         |
      |  B:net10  |
       |         |
        \\     //
          -----
            |
            |
       +----------+
       |   NAT    |
       +----------+
            |
            |
          -----
        //     \\
       |    A    |
      |192.168/16 |
       |         |
        \\     //
          -----
            |
            |
            |192.168.1.100      -----
       +----------+           //     \\             +----------+
       |          |          |         |            |          |
       | Initiator|---------|  C:net10  |-----------| Responder|
       |          |10.0.1.100|         | 10.0.1.101 |          |
       +----------+           \\     //             +----------+
                                -----


</pre>
<p class="figure">Figure 11: Identical Candidates with Different Bases</p>
<p id="rfc.section.B.2.p.2">In this case, the initiating agent is multihomed. It has one IP address, 10.0.1.100, on network C, which is a net 10 private network. The responding agent is on this same network. The initiating agent is also connected to network A, which is 192.168/16 and has an IP address of 192.168.1.100 on this network. There is a NAT on this network, natting into network B, which is another net 10 private network, but not connected to network C. There is a STUN server on network B.  </p>
<p id="rfc.section.B.2.p.3">The initiating agent obtains a host candidate on its IP address on network C (10.0.1.100:2498) and a host candidate on its IP address on network A (192.168.1.100:3344). It performs a STUN query to its configured STUN server from 192.168.1.100:3344. This query passes through the NAT, which happens to assign the binding 10.0.1.100:2498. The STUN server reflects this in the STUN Binding response. Now, the initiating agent has obtained a server reflexive candidate with a transport address that is identical to a host candidate (10.0.1.100:2498). However, the server reflexive candidate has a base of 192.168.1.100:3344, and the host candidate has a base of 10.0.1.100:2498.  </p>
<h1 id="rfc.appendix.B.3"><a href="#rfc.appendix.B.3">B.3.</a> <a href="#sec-translation" id="sec-translation">Purpose of the Related Address and Related Port Attributes</a></h1>
<p id="rfc.section.B.3.p.1">The candidate attribute contains two values that are not used at all by ICE itself -- related address and related port. Why are they present? </p>
<p id="rfc.section.B.3.p.2">There are two motivations for its inclusion. The first is diagnostic. It is very useful to know the relationship between the different types of candidates. By including it, an agent can know which relayed candidate is associated with which reflexive candidate, which in turn is associated with a specific host candidate. When checks for one candidate succeed and not for others, this provides useful diagnostics on what is going on in the network.  </p>
<p id="rfc.section.B.3.p.3">The second reason has to do with off-path Quality of Service (QoS) mechanisms. When ICE is used in environments such as PacketCable 2.0, proxies will, in addition to performing normal SIP operations, inspect the SDP in SIP messages, and extract the IP address and port for media traffic. They can then interact, through policy servers, with access routers in the network, to establish guaranteed QoS for the media flows. This QoS is provided by classifying the RTP traffic based on 5-tuple, and then providing it a guaranteed rate, or marking its Diffserv codepoints appropriately. When a residential NAT is present, and a relayed candidate gets selected for media, this relayed candidate will be a transport address on an actual TURN server. That address says nothing about the actual transport address in the access router that would be used to classify packets for QoS treatment. Rather, the server reflexive candidate towards the TURN server is needed. By carrying the translation in the SDP, the proxy can use that transport address to request QoS from the access router.  </p>
<h1 id="rfc.appendix.B.4"><a href="#rfc.appendix.B.4">B.4.</a> <a href="#sec-why-uname" id="sec-why-uname">Importance of the STUN Username</a></h1>
<p id="rfc.section.B.4.p.1">ICE requires the usage of message integrity with STUN using its short-term credential functionality. The actual short-term credential is formed by exchanging username fragments in the candidate exchange. The need for this mechanism goes beyond just security; it is actually required for correct operation of ICE in the first place.  </p>
<p id="rfc.section.B.4.p.2">Consider agents L, R, and Z. L and R are within private enterprise 1, which is using 10.0.0.0/8. Z is within private enterprise 2, which is also using 10.0.0.0/8. As it turns out, R and Z both have IP address 10.0.1.1. L sends candidates to Z. Z, in responds L with its host candidates. In this case, those candidates are 10.0.1.1:8866 and 10.0.1.1:8877. As it turns out, R is in a session at that same time, and is also using 10.0.1.1:8866 and 10.0.1.1:8877 as host candidates. This means that R is prepared to accept STUN messages on those ports, just as Z is. L will send a STUN request to 10.0.1.1:8866 and another to 10.0.1.1:8877. However, these do not go to Z as expected. Instead, they go to R! If R just replied to them, L would believe it has connectivity to Z, when in fact it has connectivity to a completely different user, R. To fix this, the STUN short-term credential mechanisms are used. The username fragments are sufficiently random that it is highly unlikely that R would be using the same values as Z. Consequently, R would reject the STUN request since the credentials were invalid. In essence, the STUN username fragments provide a form of transient host identifiers, bound to a particular session established as part of the candidate exchange.  </p>
<p id="rfc.section.B.4.p.3">An unfortunate consequence of the non-uniqueness of IP addresses is that, in the above example, R might not even be an ICE agent. It could be any host, and the port to which the STUN packet is directed could be any ephemeral port on that host. If there is an application listening on this socket for packets, and it is not prepared to handle malformed packets for whatever protocol is in use, the operation of that application could be affected. Fortunately, since the ports exchanged are ephemeral and usually drawn from the dynamic or registered range, the odds are good that the port is not used to run a server on host R, but rather is the agent side of some protocol. This decreases the probability of hitting an allocated port, due to the transient nature of port usage in this range. However, the possibility of a problem does exist, and network deployers should be prepared for it. Note that this is not a problem specific to ICE; stray packets can arrive at a port at any time for any type of protocol, especially ones on the public Internet. As such, this requirement is just restating a general design guideline for Internet applications -- be prepared for unknown packets on any port.  </p>
<h1 id="rfc.appendix.B.5"><a href="#rfc.appendix.B.5">B.5.</a> The Candidate Pair Priority Formula</h1>
<p id="rfc.section.B.5.p.1">The priority for a candidate pair has an odd form. It is: </p>
<p/>

<ul class="empty">
  <li>pair priority = 2^32*MIN(G,D) + 2*MAX(G,D) + (G&gt;D?1:0) </li>
</ul>
<p id="rfc.section.B.5.p.3">Why is this? When the candidate pairs are sorted based on this value, the resulting sorting has the MAX/MIN property. This means that the pairs are first sorted based on decreasing value of the minimum of the two priorities. For pairs that have the same value of the minimum priority, the maximum priority is used to sort amongst them. If the max and the min priorities are the same, the controlling agent's priority is used as the tie-breaker in the last part of the expression. The factor of 2*32 is used since the priority of a single candidate is always less than 2*32, resulting in the pair priority being a "concatenation" of the two component priorities.  This creates the MAX/MIN sorting. MAX/MIN ensures that, for a particular agent, a lower-priority candidate is never used until all higher-priority candidates have been tried.  </p>
<h1 id="rfc.appendix.B.6"><a href="#rfc.appendix.B.6">B.6.</a> Why Are Keepalives Needed?</h1>
<p id="rfc.section.B.6.p.1">Once media begins flowing on a candidate pair, it is still necessary to keep the bindings alive at intermediate NATs for the duration of the session. Normally, the media stream packets themselves (e.g., RTP) meet this objective. However, several cases merit further discussion. Firstly, in some RTP usages, such as SIP, the media streams can be "put on hold". This is accomplished by using the SDP "sendonly" or "inactive" attributes, as defined in RFC 3264 <a href="#RFC3264">[RFC3264]</a>. RFC 3264 directs implementations to cease transmission of media in these cases. However, doing so may cause NAT bindings to timeout, and media won't be able to come off hold.  </p>
<p id="rfc.section.B.6.p.2">Secondly, some RTP payload formats, such as the payload format for text conversation <a href="#RFC4103">[RFC4103]</a>, may send packets so infrequently that the interval exceeds the NAT binding timeouts.  </p>
<p id="rfc.section.B.6.p.3">Thirdly, if silence suppression is in use, long periods of silence may cause media transmission to cease sufficiently long for NAT bindings to time out.  </p>
<p id="rfc.section.B.6.p.4">For these reasons, the media packets themselves cannot be relied upon. ICE defines a simple periodic keepalive utilizing STUN Binding indications.  This makes its bandwidth requirements highly predictable, and thus amenable to QoS reservations.  </p>
<h1 id="rfc.appendix.B.7"><a href="#rfc.appendix.B.7">B.7.</a> Why Prefer Peer Reflexive Candidates?</h1>
<p><a href="#sec-prioritizing">Section 4.1.2</a> describes procedures for computing the priority of candidate based on its type and local preferences. That section requires that the type preference for peer reflexive candidates always be higher than server reflexive. Why is that? The reason has to do with the security considerations in <a href="#sec-security">Section 14</a>. It is much easier for an attacker to cause an agent to use a false server reflexive candidate than it is for an attacker to cause an agent to use a false peer reflexive candidate. Consequently, attacks against address gathering with Binding requests are thwarted by ICE by preferring the peer reflexive candidates.  </p>
<h1 id="rfc.appendix.B.8"><a href="#rfc.appendix.B.8">B.8.</a> Why Are Binding Indications Used for Keepalives?</h1>
<p id="rfc.section.B.8.p.1">Media keepalives are described in <a href="#sec-keepalives">Section 9</a>. These keepalives make use of STUN when both endpoints are ICE capable. However, rather than using a Binding request transaction (which generates a response), the keepalives use an Indication. Why is that? </p>
<p id="rfc.section.B.8.p.2">The primary reason has to do with network QoS mechanisms. Once media begins flowing, network elements will assume that the media stream has a fairly regular structure, making use of periodic packets at fixed intervals, with the possibility of jitter. If an agent is sending media packets, and then receives a Binding request, it would need to generate a response packet along with its media packets. This will increase the actual bandwidth requirements for the 5-tuple carrying the media packets, and introduce jitter in the delivery of those packets. Analysis has shown that this is a concern in certain layer 2 access networks that use fairly tight packet schedulers for media.  </p>
<p id="rfc.section.B.8.p.3">Additionally, using a Binding Indication allows integrity to be disabled, allowing for better performance. This is useful for large-scale endpoints, such as PSTN gateways and SBCs.  </p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ari Keranen</span> 
	  <span class="n hidden">
		<span class="family-name">Keranen</span>
	  </span>
	</span>
	<span class="org vcardline">Ericsson</span>
	<span class="adr">
	  <span class="vcardline">Hirsalantie 11</span>

	  <span class="vcardline">
		<span class="locality">02420 Jorvas</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Finland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ari.keranen@ericsson.com">ari.keranen@ericsson.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christer Holmberg</span> 
	  <span class="n hidden">
		<span class="family-name">Holmberg</span>
	  </span>
	</span>
	<span class="org vcardline">Ericsson</span>
	<span class="adr">
	  <span class="vcardline">Hirsalantie 11</span>

	  <span class="vcardline">
		<span class="locality">02420 Jorvas</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Finland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:christer.holmberg@ericsson.com">christer.holmberg@ericsson.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jonathan Rosenberg</span> 
	  <span class="n hidden">
		<span class="family-name">Rosenberg</span>
	  </span>
	</span>
	<span class="org vcardline">jdrosen.net</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Monmouth</span>,  
		<span class="region">NJ</span> 
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">US</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jdrosen@jdrosen.net">jdrosen@jdrosen.net</a></span>

<span class="vcardline">URI: <a href="http://www.jdrosen.net">http://www.jdrosen.net</a></span>

  </address>
</div>

</body>
</html>
